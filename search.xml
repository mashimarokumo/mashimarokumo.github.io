<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenCVForUnity+DlibFaceLandmarkDetector实现简单live2d面部捕捉</title>
      <link href="/posts/shi-yan-er/"/>
      <url>/posts/shi-yan-er/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenCVForUnity-DlibFaceLandmarkDetector实现简单live2d面部捕捉"><a href="#OpenCVForUnity-DlibFaceLandmarkDetector实现简单live2d面部捕捉" class="headerlink" title="OpenCVForUnity+DlibFaceLandmarkDetector实现简单live2d面部捕捉"></a><code>OpenCVForUnity+DlibFaceLandmarkDetector</code>实现简单live2d面部捕捉</h2><h3 id="实现环境"><a href="#实现环境" class="headerlink" title="实现环境"></a>实现环境</h3><ol><li>Unity2021.3.20f1c1</li><li>OpenCVForUnity2.5.8</li><li>Dlib FaceLandmark Detector 1.3.3</li><li>CubismSdkForUnity-5-r.2</li></ol><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h4><p>使用Unity中的WebCam实现。开个携程，异步等待用户允许摄像机使用，先获取设备，然后获取WebCamTexture格式的图像，转成Texture2d后即可使用OpenCVForUnity中的texture2DToMat工具获取到该图像的Mat，以便接下来用OpenCV对图像进行操作。</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//等待用户允许访问</span>        yield <span class="token keyword">return</span> Application<span class="token punctuation">.</span><span class="token function">RequestUserAuthorization</span><span class="token punctuation">(</span>UserAuthorization<span class="token punctuation">.</span>WebCam<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果用户允许访问，开始获取图像        </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Application<span class="token punctuation">.</span><span class="token function">HasUserAuthorization</span><span class="token punctuation">(</span>UserAuthorization<span class="token punctuation">.</span>WebCam<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//先获取设备</span>            WebCamDevice<span class="token punctuation">[</span><span class="token punctuation">]</span> devices <span class="token operator">=</span> WebCamTexture<span class="token punctuation">.</span>devices<span class="token punctuation">;</span>            string deviceName <span class="token operator">=</span> devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//然后获取图像</span>            tex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebCamTexture</span><span class="token punctuation">(</span>deviceName<span class="token punctuation">)</span><span class="token punctuation">;</span>            tex<span class="token punctuation">.</span><span class="token function">Play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Mat camMat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Size</span><span class="token punctuation">(</span>tex<span class="token punctuation">.</span>width<span class="token punctuation">,</span> tex<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> CvType<span class="token punctuation">.</span>CV_8UC3<span class="token punctuation">)</span><span class="token punctuation">;</span>            Mat gray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            MatOfRect faceRect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MatOfRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            openCam <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>tex<span class="token punctuation">.</span>isPlaying<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                Texture2D t2d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Texture2D</span><span class="token punctuation">(</span>tex<span class="token punctuation">.</span>width<span class="token punctuation">,</span> tex<span class="token punctuation">.</span>height<span class="token punctuation">,</span> TextureFormat<span class="token punctuation">.</span>ARGB32<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//将WebCamTexture 的像素保存到texture2D中</span>                t2d<span class="token punctuation">.</span><span class="token function">SetPixels</span><span class="token punctuation">(</span>tex<span class="token punctuation">.</span><span class="token function">GetPixels</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                t2d<span class="token punctuation">.</span><span class="token function">Apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>camMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> CvType<span class="token punctuation">.</span>CV_8UC1<span class="token punctuation">)</span>                    Imgproc<span class="token punctuation">.</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>camMat<span class="token punctuation">,</span> camMat<span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>COLOR_GRAY2BGR<span class="token punctuation">)</span><span class="token punctuation">;</span>                Utils<span class="token punctuation">.</span><span class="token function">texture2DToMat</span><span class="token punctuation">(</span>t2d<span class="token punctuation">,</span> camMat<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="识别人脸并获取Landmark"><a href="#识别人脸并获取Landmark" class="headerlink" title="识别人脸并获取Landmark"></a>识别人脸并获取Landmark</h4><p>这边使用OpenCV自带的CascadeClassifie库好像也可以实现？我用的是Dlib FaceLandmark Detector中的FaceLandmarkDetector</p><p>先检测出人脸的位置，获取到Rect后对其进行人脸的68点定位。我使用的是Dlib FaceLandmark Detector官方StreamingAssets中的sp_human_face_68.dat文件。</p><pre class="line-numbers language-java"><code class="language-java">detector<span class="token punctuation">.</span><span class="token function">SetImage</span><span class="token punctuation">(</span><span class="token punctuation">(</span>IntPtr<span class="token punctuation">)</span>camMat<span class="token punctuation">.</span><span class="token function">dataAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> camMat<span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> camMat<span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>camMat<span class="token punctuation">.</span><span class="token function">elemSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                List<span class="token operator">&lt;</span>UnityEngine<span class="token punctuation">.</span>Rect<span class="token operator">></span> rects <span class="token operator">=</span> detector<span class="token punctuation">.</span><span class="token function">Detect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rects<span class="token punctuation">.</span>Count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    Imgproc<span class="token punctuation">.</span><span class="token function">rectangle</span><span class="token punctuation">(</span>camMat<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+</span> rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>width<span class="token punctuation">,</span> rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+</span> rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Scalar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//在原本的画面中画框，框出人脸额位置,其中rects[i].x和rects[i].y为框的左上角的顶点，rects[i].width、rects[i].height即为框的宽和高</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// create a face detector</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rects<span class="token punctuation">.</span>Count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    detector<span class="token punctuation">.</span><span class="token function">SetImage</span><span class="token punctuation">(</span><span class="token punctuation">(</span>IntPtr<span class="token punctuation">)</span>camMat<span class="token punctuation">.</span><span class="token function">dataAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> camMat<span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> camMat<span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>camMat<span class="token punctuation">.</span><span class="token function">elemSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    List<span class="token operator">&lt;</span>Vector2<span class="token operator">></span> points <span class="token operator">=</span> detector<span class="token punctuation">.</span><span class="token function">DetectLandmark</span><span class="token punctuation">(</span>rects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// Debug.Log(points.Count);</span>                    <span class="token function">DrawLandmark</span><span class="token punctuation">(</span>camMat<span class="token punctuation">,</span> points<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Scalar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="估计人脸姿态"><a href="#估计人脸姿态" class="headerlink" title="估计人脸姿态"></a>估计人脸姿态</h4><p><a href="https://zhuanlan.zhihu.com/p/146835462">参考博客</a></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master//res/20240524163430.png" alt="image-20240524162803631" style="zoom:33%;"><p>首先定义6关键点的3D Model。</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//set 3d face object points.</span>        objectPoints68 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MatOfPoint3f</span><span class="token punctuation">(</span>               <span class="token keyword">new</span> <span class="token class-name">Point3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">83</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//l eye (Interpupillary breadth)</span>               <span class="token keyword">new</span> <span class="token class-name">Point3</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">83</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//r eye (Interpupillary breadth)</span>               <span class="token keyword">new</span> <span class="token class-name">Point3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">117</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//nose (Tip)</span>               <span class="token keyword">new</span> <span class="token class-name">Point3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//nose (Subnasale)</span>               <span class="token keyword">new</span> <span class="token class-name">Point3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">79</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//l ear (Bitragion breadth)</span>               <span class="token keyword">new</span> <span class="token class-name">Point3</span><span class="token punctuation">(</span><span class="token number">79</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//r ear (Bitragion breadth)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后基于刚刚产生的landmark检测出六关键点，并传入OpenCV的solvePnP中进行姿态估计。用AR工具将得到的数据转换为poseData。由于Unity是左手坐标系，OpenCV是右手系，还需要进行矩阵的转换。最后经过一个我不是很懂的PV坐标转换得到最终的旋转四元数。</p><pre class="line-numbers language-java"><code class="language-java"> imagePoints<span class="token punctuation">.</span><span class="token function">fromArray</span><span class="token punctuation">(</span>                               <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+</span> points<span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+</span> points<span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//l eye (Interpupillary breadth)</span>                               <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+</span> points<span class="token punctuation">[</span><span class="token number">46</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+</span> points<span class="token punctuation">[</span><span class="token number">46</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//r eye (Interpupillary breadth)</span>                               <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//nose (Tip)</span>                               <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//nose (Subnasale)</span>                               <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//l ear (Bitragion breadth)</span>                               <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> points<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//r ear (Bitragion breadth)</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">SetCameraMatrix</span><span class="token punctuation">(</span>camMatrix<span class="token punctuation">,</span> camMat<span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> camMat<span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Calib3d<span class="token punctuation">.</span><span class="token function">solvePnP</span><span class="token punctuation">(</span>objectPoints68<span class="token punctuation">,</span> imagePoints<span class="token punctuation">,</span> camMatrix<span class="token punctuation">,</span> distCoeffs<span class="token punctuation">,</span> rvec<span class="token punctuation">,</span> tvec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Convert to unity pose data.</span>                        <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rvecArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        rvec<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> rvecArr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tvecArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        tvec<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> tvecArr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        PoseData poseData <span class="token operator">=</span> ARUtils<span class="token punctuation">.</span><span class="token function">ConvertRvecTvecToPoseData</span><span class="token punctuation">(</span>rvecArr<span class="token punctuation">,</span> tvecArr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// adjust the position to the scale of real-world space.</span>                        poseData<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector3</span><span class="token punctuation">(</span>poseData<span class="token punctuation">.</span>pos<span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token number">0.001f</span><span class="token punctuation">,</span> poseData<span class="token punctuation">.</span>pos<span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token number">0.001f</span><span class="token punctuation">,</span> poseData<span class="token punctuation">.</span>pos<span class="token punctuation">.</span>z <span class="token operator">*</span> <span class="token number">0.001f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Matrix4x4 transformationM <span class="token operator">=</span> Matrix4x4<span class="token punctuation">.</span><span class="token function">TRS</span><span class="token punctuation">(</span>poseData<span class="token punctuation">.</span>pos<span class="token punctuation">,</span> poseData<span class="token punctuation">.</span>rot<span class="token punctuation">,</span> Vector3<span class="token punctuation">.</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// right-handed coordinates system (OpenCV) to left-handed one (Unity)</span>                        <span class="token comment" spellcheck="true">// https://stackoverflow.com/questions/30234945/change-handedness-of-a-row-major-4x4-transformation-matrix</span>                        transformationM <span class="token operator">=</span> invertYM <span class="token operator">*</span> transformationM <span class="token operator">*</span> invertYM<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// Apply Y-axis and Z-axis refletion matrix. (Adjust the posture of the AR object)</span>                        transformationM <span class="token operator">=</span> transformationM <span class="token operator">*</span> invertYM <span class="token operator">*</span> invertZM<span class="token punctuation">;</span>                        Vector3 headPosition <span class="token operator">=</span> ARUtils<span class="token punctuation">.</span><span class="token function">ExtractTranslationFromMatrix</span><span class="token punctuation">(</span>ref transformationM<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Quaternion headRotation <span class="token operator">=</span> ARUtils<span class="token punctuation">.</span><span class="token function">ExtractRotationFromMatrix</span><span class="token punctuation">(</span>ref transformationM<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我将这个四元数的旋转赋值到一个父物体上，通过子物体坐标的偏移实现live2d所需的lookatTarget。通过子物体坐标参数的调整达到最终还算可以的效果。这是我子物体的位置参数。这个可能要按实际情况自己慢慢调。</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master//res/20240524165042.png" alt="image-20240524165041997"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master//res/20240524165057.png" alt="image-20240524165057460"></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master//res/20240524164934.gif" alt="1716540512844 00_00_00-00_00_30" style="zoom:50%;"><h4 id="眼睛开闭检测"><a href="#眼睛开闭检测" class="headerlink" title="眼睛开闭检测"></a>眼睛开闭检测</h4><p><a href="https://blog.csdn.net/new9232/article/details/134095167">参考博客</a></p><img src="https://img-blog.csdnimg.cn/e44e8cb44b564225b58943231e9ee71b.jpeg" alt="img" style="zoom:50%;"><p>我们可以通过人眼纵横比判断眨眼。由纵横比公式与68点人脸特征图可知，对于左眼，我们可以通过38和42的距离加上39和41的距离减去37和40的距离乘2计算出纵横比。经实验这些数据基本处于0-0.25之间，且与睁眼的幅度成正相关，故归一化后传给live2d实现眨眼。</p><p><img src="https://img-blog.csdnimg.cn/417de6da701b47bca87b7705474d7a96.png" alt="人眼纵横比"></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master//res/20240524165710.png" alt="image-20240524165710068"></p><pre class="line-numbers language-java"><code class="language-java">                      #region eyeOpen                        <span class="token keyword">float</span> A <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">36</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">36</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        <span class="token keyword">float</span> B <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">36</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">36</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        <span class="token keyword">float</span> C <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">36</span> <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">36</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        <span class="token keyword">float</span> ratel <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>C <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">0.25f</span><span class="token punctuation">;</span>                        A <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">42</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">42</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        B <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">42</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">42</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        C <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">42</span> <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">42</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        <span class="token keyword">float</span> rater <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>C <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">0.25f</span><span class="token punctuation">;</span>                        eyeOpen<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">BlendToValue</span><span class="token punctuation">(</span>CubismParameterBlendMode<span class="token punctuation">.</span>Override<span class="token punctuation">,</span> ratel<span class="token punctuation">)</span><span class="token punctuation">;</span>                        eyeOpen<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">BlendToValue</span><span class="token punctuation">(</span>CubismParameterBlendMode<span class="token punctuation">.</span>Override<span class="token punctuation">,</span> rater<span class="token punctuation">)</span><span class="token punctuation">;</span>                        #endregion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master//res/20240524170130.gif" alt="1716541225828"></p><h4 id="张嘴检测"><a href="#张嘴检测" class="headerlink" title="张嘴检测"></a>张嘴检测</h4><p>其实这部分的效果不是很好。和眼睛一样，我采用了计算纵横比的方法判断嘴的开合，经实验当人物处于正面对摄像头时较为准确，而当人物侧对摄像头时有时会自动张嘴。可能是侧对摄像头时横向看到的嘴小了，纵横比不能很好的胜任。</p><p><img src="https://img-blog.csdnimg.cn/76707621231a42adb8c8a0a79e30c065.png" alt="嘴部特征点图"></p><pre class="line-numbers language-java"><code class="language-java">                        #region mouse                        C <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">48</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        A <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">51</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        B <span class="token operator">=</span> <span class="token punctuation">(</span>points<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span> <span class="token operator">-</span> points<span class="token punctuation">[</span><span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>magnitude<span class="token punctuation">;</span>                        <span class="token keyword">float</span> mouth <span class="token operator">=</span> <span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>C <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//Debug.Log(mouth);</span>                        mouth <span class="token operator">=</span> <span class="token punctuation">(</span>mouth <span class="token operator">-</span> <span class="token number">0.7f</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">0.2f</span><span class="token punctuation">;</span>                        mouthOpen<span class="token punctuation">.</span>MouthOpening <span class="token operator">=</span> mouth<span class="token punctuation">;</span>                        #endregion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master//res/20240524170613.gif" alt="1716541538875"></p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><p>关于这几个插件网上都没有详细的资料，我只能自己一步步摸索，看看官方案例的源码。模型也是官方的场景里拖过来用的。其中CVVtuberExample也帮了我很大的忙。最后能自己实现个面部捕捉系统还是很有成就感的。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Computer Graphics </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于OpenCVForUnity的图像美化系统</title>
      <link href="/posts/unity-tu-xiang-mei-hua-xi-tong/"/>
      <url>/posts/unity-tu-xiang-mei-hua-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="前言介绍"><a href="#前言介绍" class="headerlink" title="前言介绍"></a>前言介绍</h2><p>​这篇文章的起因是数字图像处理这门课程的作业需要做一个基于OpenCV的图像美化系统，感觉OpenCV的各种环境配置有点麻烦，之前看到朋友用过插件实现在Unity中使用OpenCV的接口，我就寻思为什么不用Unity做这个作业呢，于是找到了<code>OpenCVForUnity</code>这个插件开整。上手后发现网上关于该插件的文章较少。虽说该插件是Java版OpenCV的复制，理论上使用起来几乎没有区别，但是经实际使用还是出现了一些问题，于是我打算将我的使用经历及踩坑情况一一记录下来。</p><p>​本文使用的Unity版本为2020.3.40f1c1版，<code>OpenCVForUnity</code>插件版本为2.5.8</p><p>​<a href="https://github.com/mashimarokumo/ImageProcess">项目地址</a>（不包含插件）</p><p>​<a href="https://github.com/mashimarokumo/ImageProcess/releases/download/v0.0.1/BIN.zip">成品地址</a></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504222543.png" alt="成品展示图"></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="图片的读取与保存"><a href="#图片的读取与保存" class="headerlink" title="图片的读取与保存"></a>图片的读取与保存</h3><p>​作业要求是自选图片地址打开，而Unity本身并没有对资源管理器中操作的相关支持。查询资料后发现需要引入c#中Comdlg.dll中的方法实现打开任务管理器并获取到用户选择文件路径。故通过此方法附加上OpenCV中自带的<code>imread</code>方法读取图像，通过<code>imwrite</code>方法保存图像。在此插件中两方法都位于<code>Imgcodecs</code>类中。代码与使用效果如下：</p><p><a href="https://blog.csdn.net/yu1368072332/article/details/89413263">参考博客地址</a></p><p>(<code>不知道为什么选c#没有代码高亮 这边就选java了 ouo</code>)</p><h4 id="引入dll"><a href="#引入dll" class="headerlink" title="引入dll"></a>引入<code>dll</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 调用系统的窗口,数据接收类</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token punctuation">[</span><span class="token function">StructLayout</span><span class="token punctuation">(</span>LayoutKind<span class="token punctuation">.</span>Sequential<span class="token punctuation">,</span> CharSet <span class="token operator">=</span> CharSet<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OpenFileName</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> structSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr dlgOwner <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr instance <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> String filter <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> String customFilter <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> maxCustFilter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> filterIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String file <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> maxFile <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String fileTitle <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> maxFileTitle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String initialDir <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> String title <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">short</span> fileOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">short</span> fileExtension <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String defExt <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr custData <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr hook <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> String templateName <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr reservedPtr <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> reservedInt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> flagsEx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WindowDll</span><span class="token punctuation">{</span>    <span class="token punctuation">[</span><span class="token function">DllImport</span><span class="token punctuation">(</span><span class="token string">"Comdlg32.dll"</span><span class="token punctuation">,</span> SetLastError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> ThrowOnUnmappableChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> CharSet <span class="token operator">=</span> CharSet<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> extern bool <span class="token function">GetOpenFileName</span><span class="token punctuation">(</span><span class="token punctuation">[</span>In<span class="token punctuation">,</span> Out<span class="token punctuation">]</span> OpenFileName ofn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token function">DllImport</span><span class="token punctuation">(</span><span class="token string">"Comdlg32.dll"</span><span class="token punctuation">,</span> SetLastError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> ThrowOnUnmappableChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> CharSet <span class="token operator">=</span> CharSet<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> extern bool <span class="token function">GetSaveFileName</span><span class="token punctuation">(</span><span class="token punctuation">[</span>In<span class="token punctuation">,</span> Out<span class="token punctuation">]</span> OpenFileName ofd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h4><p>​除了上述问题，在这部分还出了一个小插曲。由于正版插件很贵，我也只用于学习用途，我原本是在网上随便找了一个版本的插件，用<code>imread</code>读取图片时完全没有出现问题。后来由于该版本在噪声添加方面有不可解决的问题，我又找到了现在的2.5.8版本。替换后发现读取完的图片直接用<code>matToTexture2D</code>转为Texture显示后突然出现倒置现象。找了很久的问题也没有解决，最后采用了读取后手动转正的方法。在保存时也出现了类似的问题，可能和插件中实现方式有关。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Mat <span class="token function">LoadPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        OpenFileName ofn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>structSize <span class="token operator">=</span> Marshal<span class="token punctuation">.</span><span class="token function">SizeOf</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>filter <span class="token operator">=</span> <span class="token string">"图片文件(*.jpg*.png)\0*.jpg;*.png"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//显示的可选文件</span>        ofn<span class="token punctuation">.</span>file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFile <span class="token operator">=</span> ofn<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>fileTitle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFileTitle <span class="token operator">=</span> ofn<span class="token punctuation">.</span>fileTitle<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        string path <span class="token operator">=</span> Application<span class="token punctuation">.</span>streamingAssetsPath<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//默认路径</span>        path <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>initialDir <span class="token operator">=</span> path<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"Open Project"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>defExt <span class="token operator">=</span> <span class="token string">"JPG"</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//注意 以下项目不一定要全选 但是0x00000008项不要缺少</span>        ofn<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0x00080000</span> <span class="token operator">|</span> <span class="token number">0x00001000</span> <span class="token operator">|</span> <span class="token number">0x00000800</span> <span class="token operator">|</span> <span class="token number">0x00000200</span> <span class="token operator">|</span> <span class="token number">0x00000008</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OFN_EXPLORER|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST| OFN_ALLOWMULTISELECT|OFN_NOCHANGEDIR</span>        <span class="token comment" spellcheck="true">//点击Windows窗口时开始加载选中的图片</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>WindowDll<span class="token punctuation">.</span><span class="token function">GetOpenFileName</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Selected file with full path: "</span> <span class="token operator">+</span> ofn<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>            Utils<span class="token punctuation">.</span><span class="token function">setDebugMode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Mat read <span class="token operator">=</span> Imgcodecs<span class="token punctuation">.</span><span class="token function">imread</span><span class="token punctuation">(</span>Utils<span class="token punctuation">.</span><span class="token function">getFilePath</span><span class="token punctuation">(</span>ofn<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">,</span> Imgcodecs<span class="token punctuation">.</span>IMREAD_UNCHANGED<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//得到图片，读取图片通道类型遵循原图片类型</span>            <span class="token comment" spellcheck="true">//手动反转两次</span>            Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>read<span class="token punctuation">,</span> read<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>read<span class="token punctuation">,</span> read<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将原本读取的RGB颜色类型转换成Mat存储适用的BGR颜色类型</span>            Imgproc<span class="token punctuation">.</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>read<span class="token punctuation">,</span> read<span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>COLOR_RGBA2BGRA<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> read<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SavePic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        OpenFileName ofn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>structSize <span class="token operator">=</span> Marshal<span class="token punctuation">.</span><span class="token function">SizeOf</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>filter <span class="token operator">=</span> <span class="token string">"图片文件(*.jpg*.png)\0*.jpg;*.png"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFile <span class="token operator">=</span> ofn<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>fileTitle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFileTitle <span class="token operator">=</span> ofn<span class="token punctuation">.</span>fileTitle<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        string path <span class="token operator">=</span> Application<span class="token punctuation">.</span>streamingAssetsPath<span class="token punctuation">;</span>        path <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>initialDir <span class="token operator">=</span> path<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"Open Project"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>defExt <span class="token operator">=</span> <span class="token string">"JPG"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0x00080000</span> <span class="token operator">|</span> <span class="token number">0x00001000</span> <span class="token operator">|</span> <span class="token number">0x00000800</span> <span class="token operator">|</span> <span class="token number">0x00000200</span> <span class="token operator">|</span> <span class="token number">0x00000008</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>WindowDll<span class="token punctuation">.</span><span class="token function">GetSaveFileName</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">CancelOption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Mat toSave <span class="token operator">=</span> savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>toSave<span class="token punctuation">,</span> toSave<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//手动反转</span>            Imgproc<span class="token punctuation">.</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>toSave<span class="token punctuation">,</span> toSave<span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>COLOR_BGRA2RGBA<span class="token punctuation">)</span><span class="token punctuation">;</span>            Imgcodecs<span class="token punctuation">.</span><span class="token function">imwrite</span><span class="token punctuation">(</span>ofn<span class="token punctuation">.</span>file<span class="token punctuation">,</span> toSave<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p>打开</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504222016.png"></p><p>保存</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504222231.png"></p><h3 id="调整明亮度与对比度"><a href="#调整明亮度与对比度" class="headerlink" title="调整明亮度与对比度"></a>调整明亮度与对比度</h3><p>​亮度和对比度可以通过公式$\alpha * f(i,j) + \beta$来调整。其中$\alpha$可以代表对比度，$\beta$代表亮度。在OpenCV中既可以使用遍历像素的方法实现，也可以使用自带的<code>ConvertTo</code>方法快速调整。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AdjustBrightness</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat newMat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> value <span class="token operator">=</span> brightness<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">convertTo</span><span class="token punctuation">(</span>newMat<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> newMat<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AdjustAlpha</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat newMat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> value <span class="token operator">=</span> alpha<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">convertTo</span><span class="token punctuation">(</span>newMat<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> newMat<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231817.jpeg" alt="img"></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231854.jpeg" alt="img"></p><h3 id="饱和度调整"><a href="#饱和度调整" class="headerlink" title="饱和度调整"></a>饱和度调整</h3><p>算法步骤：</p><ol><li><p>计算RGB三通道的最大最小值，并进一步得到delta和value。<br>$$<br>delta = (Max - Min)/255<br>$$</p><p>$$<br>value = (Max+Min)/255<br>$$</p></li><li><p>若最大最小一致，即delta=0，则表明为灰点，不需继续操作，直接处理下个像素。</p></li><li><p>通过value算出HSL中L的值<br>$$<br>L=(Max-Min)/(2*255)<br>$$</p></li><li><p>S值为<br>$$<br>\begin{cases}<br>S=delta/value,L&lt;0.5\S=delta/(2-value),L\ge0.5<br>\end{cases}<br>$$</p></li><li><p>当percent大于等于0时，即提高色彩饱和度，那么alpha值为：<br>$$<br>\begin{cases}<br>alpha = S, percent+S\ge1\<br>alpha=1-percent,else<br>\end{cases}<br>$$<br>此时，调整后的图像RGB三通道值为：<br>$$<br>RGB=RGB+(RGB-L*255)*alpha<br>$$</p></li><li><p>若percent小于0时，即降低色彩饱和度，则alpha=percent，此时调整后的图像RGB三通道值为：<br>$$<br>RGB=L<em>255+(RGB-L</em>255)*(1-alpha)<br>$$</p></li></ol><p><a href="https://blog.csdn.net/qq_55041016/article/details/124834569">算法来源</a></p><p>​当时不知道为什么这段代码一运行程序就卡死了。后来发现是这个遍历的过程特别慢，可能算法比较复杂，在每个像素上运行计算量就很大。于是我就给它加了个协程顺便记了个时，发现它是真慢。每次运行大概要8s到12s左右。推测跟插件的效率也有关？</p><pre class="line-numbers language-java"><code class="language-java">    IEnumerator <span class="token function">Sat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat newMat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> stime <span class="token operator">=</span> Time<span class="token punctuation">.</span>time<span class="token punctuation">;</span>        <span class="token keyword">float</span> saturation <span class="token operator">=</span> sat<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>curMat<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> increment <span class="token operator">=</span> <span class="token punctuation">(</span>saturation <span class="token operator">-</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token number">200f</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> curMat<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> curMat<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// R,G,B 分别对应数组中下标的 2,1,0</span>                <span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> g <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> maxn <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> minn <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> delta<span class="token punctuation">,</span> value<span class="token punctuation">;</span>                delta <span class="token operator">=</span> <span class="token punctuation">(</span>maxn <span class="token operator">-</span> minn<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">;</span>                value <span class="token operator">=</span> <span class="token punctuation">(</span>maxn <span class="token operator">+</span> minn<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> new_r<span class="token punctuation">,</span> new_g<span class="token punctuation">,</span> new_b<span class="token punctuation">;</span>                <span class="token keyword">float</span> light<span class="token punctuation">,</span> sat<span class="token punctuation">,</span> alpha<span class="token punctuation">;</span>                light <span class="token operator">=</span> value <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>light <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span>                    sat <span class="token operator">=</span> delta <span class="token operator">/</span> value<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    sat <span class="token operator">=</span> delta <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">-</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>increment <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>increment <span class="token operator">+</span> sat<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>                        alpha <span class="token operator">=</span> sat<span class="token punctuation">;</span>                    <span class="token keyword">else</span>                    <span class="token punctuation">{</span>                        alpha <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> increment<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    alpha <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> alpha <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_r <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> alpha<span class="token punctuation">;</span>                    new_g <span class="token operator">=</span> g <span class="token operator">+</span> <span class="token punctuation">(</span>g <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> alpha<span class="token punctuation">;</span>                    new_b <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token punctuation">(</span>b <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> alpha<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    alpha <span class="token operator">=</span> increment<span class="token punctuation">;</span>                    new_r <span class="token operator">=</span> light <span class="token operator">*</span> <span class="token number">255</span> <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>                    new_g <span class="token operator">=</span> light <span class="token operator">*</span> <span class="token number">255</span> <span class="token operator">+</span> <span class="token punctuation">(</span>g <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>                    new_b <span class="token operator">=</span> light <span class="token operator">*</span> <span class="token number">255</span> <span class="token operator">+</span> <span class="token punctuation">(</span>b <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                newMat<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> new_b<span class="token punctuation">,</span> new_g<span class="token punctuation">,</span> new_r<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            yield <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> newMat<span class="token punctuation">;</span>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"f"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Time<span class="token punctuation">.</span>time <span class="token operator">-</span> stime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231920.jpeg" alt="img"></p><h3 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h3><p>​先加载边框图片，然后resize到原图大小，生成边框的灰度图作为mask，然后用<code>copyTo</code>方法附加到原图上。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">MakeBorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat border <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">LoadPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//加载边框图片</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Imgproc<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>border<span class="token punctuation">,</span> border<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调整边框大小适应图片</span>        Mat mask <span class="token operator">=</span> border<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Imgproc<span class="token punctuation">.</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>mask<span class="token punctuation">,</span> mask<span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>COLOR_BGRA2GRAY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//生成灰度图作为mask</span>        Imgproc<span class="token punctuation">.</span><span class="token function">threshold</span><span class="token punctuation">(</span>mask<span class="token punctuation">,</span> mask<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>THRESH_BINARY<span class="token punctuation">)</span><span class="token punctuation">;</span>         border<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span>curMat<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//复制边框到原图</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> curMat<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231933.jpeg" alt="img"></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231944.jpeg" alt="img"></p><h3 id="浮雕效果"><a href="#浮雕效果" class="headerlink" title="浮雕效果"></a>浮雕效果</h3><p>​经查阅浮雕效果的原理是每个像素的RGB值都设置为该位置的初始值减去其右下方第二的像素的差，最后统一加上128用于控制灰度，显示出类似浮雕的灰色。这样处理的思路是，将图像上的每个点与它的对角线的像素点形成差值，这样淡化相似的颜色，突出不同的颜色、边缘，从而使图像产生纵深感，产生类似于浮雕的效果。（<a href="https://blog.csdn.net/qq525003138/article/details/103449413">解释来自</a>）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">FuDiao</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat src <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> CvType<span class="token punctuation">.</span>CV_8UC1<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        Mat dst <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rowNumber <span class="token operator">=</span> dst<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> colNumber <span class="token operator">=</span> dst<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rowNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> colNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                dst<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">255</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> dst<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504232034.jpeg" alt="img"></p><h3 id="简单倒影效果"><a href="#简单倒影效果" class="headerlink" title="简单倒影效果"></a>简单倒影效果</h3><p>​采用随机将像素偏移一定位置的方法创造出类似倒影的效果，再将原图与倒影图上下拼接完成效果。代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Reflection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat img <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat dstImg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        img<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>dstImg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Rect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rowNumber <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> colNumber <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rowNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> colNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">int</span> deltax <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> deltay <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> deltax <span class="token operator">>=</span> colNumber<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    deltax <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> deltay <span class="token operator">>=</span> rowNumber<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    deltay <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                img<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> img<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> deltay<span class="token punctuation">,</span> j <span class="token operator">+</span> deltax<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> deltay<span class="token punctuation">,</span> j <span class="token operator">+</span> deltax<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> deltay<span class="token punctuation">,</span> j <span class="token operator">+</span> deltax<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">255</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> img<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        img<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>dstImg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Rect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> dstImg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504232051.jpeg" alt="img"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>​感觉大部分时间都花在查资料和api以及代码的调试上了，实际上并没有很多产出。还有很多内容由于一些无法解决的问题没有实现。希望之后能继续调试并完善这个项目。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Computer Graphics </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于OpenGL的Windowkill游戏复刻</title>
      <link href="/posts/ji-yu-opengl-de-windowkill-you-xi-fu-ke/"/>
      <url>/posts/ji-yu-opengl-de-windowkill-you-xi-fu-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统亮点和操作说明"><a href="#1-系统亮点和操作说明" class="headerlink" title="1.系统亮点和操作说明"></a>1.系统亮点和操作说明</h2><h3 id="1-1-总体介绍"><a href="#1-1-总体介绍" class="headerlink" title="1.1 总体介绍"></a>1.1 总体介绍</h3><p>本游戏是一个类吸血鬼幸存者<code>Rougelike</code>生存射击游戏，即结合了<code>Rougelike</code>（随机地图、永久死亡等）元素与生存、战斗玩法。游戏过程中，玩家需要击杀不断涌现的敌人，通过收集经验值和升级来增强自己的能力，并寻找合适的方法来对抗越来越强大的敌人。游戏的设计理念在于为玩家提供简单上手的游戏体验和快速通关的可能性，以此来满足现代玩家对于休闲和娱乐的需求。</p><p>而本游戏则以窗体限制视角大小，窗体会随时间不断缩小，玩家需要在通过射击扩大窗体的同时迎击不断生成的敌人，再通过敌人掉落的金币在商店中升级自己的属性。游戏总共包括三种敌人和一个boss，商店中有八种属性加成可选，比较完备。</p><h3 id="1-2系统亮点"><a href="#1-2系统亮点" class="headerlink" title="1.2系统亮点"></a>1.2系统亮点</h3><p>在传统的类吸血鬼幸存者这一游戏类型的基础上，将视角限制依托在窗体的大小变化上，并依靠子弹射击墙壁扩大窗口，要求玩家在攻击和扩大视野两个操作中做出权衡，从而增加游戏性与可玩性。</p><h3 id="1-3实现方式"><a href="#1-3实现方式" class="headerlink" title="1.3实现方式"></a>1.3实现方式</h3><p>游戏的实现全部使用c++语言，OpenGL的库中只用了<code>glut.h</code>，此外还用了c++自带的std中的<code>time.h</code>（用来重置随机数）、<code>math.h</code>（用来进行数学运算）、vector（用来存储数据）、iostream（用来输出测试）、<code>window.h</code>、<code>stdlib.h</code>、utility、<code>stdio.h</code>、string（用来实现汉字显示）、functional（用来传入函数优化代码结构）等库。</p><h3 id="1-4-操作说明"><a href="#1-4-操作说明" class="headerlink" title="1.4 操作说明"></a>1.4 操作说明</h3><p>在游戏中，按下<code>wasd</code>操作玩家（小白球）移动，按住鼠标发射子弹，方向沿玩家到鼠标的方向。（注：图中红色标记为后期加注，非游戏内内容）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505000404.jpg" alt="img" style="zoom:80%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505000411.png" alt="img" style="zoom:80%;"><p>按下空格进入商店，通过鼠标点击选择购买使角色强化，再次按下空格退出商店。</p><hr><h2 id="2．设计的目的与意义"><a href="#2．设计的目的与意义" class="headerlink" title="2．设计的目的与意义"></a>2．设计的目的与意义</h2><h3 id="2-1-设计目的"><a href="#2-1-设计目的" class="headerlink" title="2.1 设计目的"></a>2.1 设计目的</h3><p>本游戏旨在提供一个充满挑战与乐趣的Rougelike生存射击游戏体验，让玩家在游戏中体验到紧张刺激的生存战斗和策略选择。通过射击和生存机制的结合，游戏旨在培养玩家的反应能力、策略规划和决策能力。同时，游戏的设计理念是简单上手，快速通关，满足现代玩家对于休闲和娱乐的需求。</p><h3 id="2-2-设计意义："><a href="#2-2-设计意义：" class="headerlink" title="2.2 设计意义："></a>2.2 设计意义：</h3><p>2.2.1 培养玩家的反应能力和决策能力：游戏中的战斗和生存机制要求玩家在紧张的环境中快速做出决策，培养了玩家的反应能力和决策能力。</p><p>2.2.2提供休闲和娱乐：游戏旨在为玩家提供一个轻松愉悦的游戏体验，让玩家在休闲时刻享受游戏的乐趣。</p><p>2.2.3激发玩家的创造力：游戏的设计理念和机制让玩家在游戏中不断尝试新的策略和方法，激发了玩家的创造力和想象力。</p><hr><h2 id="3．总体方案设计"><a href="#3．总体方案设计" class="headerlink" title="3．总体方案设计"></a>3．总体方案设计</h2><h3 id="3-1-功能模块的划分及主要实现功能的原理"><a href="#3-1-功能模块的划分及主要实现功能的原理" class="headerlink" title="3.1 功能模块的划分及主要实现功能的原理"></a>3.1 功能模块的划分及主要实现功能的原理</h3><h4 id="3-1-1-游戏架构："><a href="#3-1-1-游戏架构：" class="headerlink" title="3.1.1 游戏架构："></a>3.1.1 游戏架构：</h4><p>游戏由11个文件组成，包括总体1.逻辑与程序入口<code>final</code>、2.所有实体的基类<code>entity</code>、3.储存玩家资料的<code>player</code>、4.储存敌人资料的敌人基类<code>enemy</code>、5.敌人派生类<code>enemyb</code>、6.敌人派生类2<code>enemyc</code>、7.敌人派生类<code>boss</code>、8.子弹控制<code>bullet</code>、9.金币控制<code>money</code>、10.粒子系统<code>particle</code>和11.商店控制<code>store</code></p><h4 id="3-1-2-游戏引擎："><a href="#3-1-2-游戏引擎：" class="headerlink" title="3.1.2 游戏引擎："></a>3.1.2 游戏引擎：</h4><p>在游戏循环管理上，我进行了统一管理操作。对于所有可在屏幕上显示的实体，我均使它们继承自entity类，并在创建时加入链表统一管理。我用一个<code>glutTimerFunc</code>统筹了所有的游戏循环的实现与图形的绘制，方便了后续的代码编写和修改。</p><p>在图形渲染（使用OpenGL）上，由于实际游戏存在大于窗口展示画面，而glut的绘制是以窗口坐下为原点的，我将坐标简单分为实际坐标（物体在实际游戏中，即以屏幕左下角为原点的坐标系中所属坐标）和画面坐标（物体在以窗口左下角为原点的坐标系中所属的坐标）两种，在存储与计算时运用实际坐标，并在绘制过程中转换成画面坐标。绘制采用每帧重绘的方式，时间为1ms每帧。</p><p>在输入处理（键盘和鼠标）上，我则使用了glut自带的键鼠输入函数实现。</p><h4 id="3-1-3-游戏玩法："><a href="#3-1-3-游戏玩法：" class="headerlink" title="3.1.3 游戏玩法："></a>3.1.3 游戏玩法：</h4><p>玩家移动和控制和射击机制由3.1中输入实现。</p><p>敌人有最基础的enemy类（追着角色跑）推广到<code>enemyb</code>（每过一段时间冲向角色）和<code>enemyc</code>（向角色发射子弹），最后推广至boss（发射激光，造成一定伤害后随机移动，以强化推墙机制）生成时，敌人会随机生成在画面外并追击玩家。敌人的最大生成数量会随时间增加而增加，生成间隔则会随时间减小，从而增加游戏难度，以适应属性不断增强的玩家。</p><p>商店由输入系统检测空格按键打开，同时改变游戏模式使游戏画面暂停，并在商店窗口中显示ui。</p><p>金币掉落数由随机数及玩家金币掉落率属性决定。</p><h4 id="3-1-4-用户界面："><a href="#3-1-4-用户界面：" class="headerlink" title="3.1.4 用户界面："></a>3.1.4 用户界面：</h4><p>窗口大小与位置由全局循环实时改变，ui显示与entity显示方式一致。</p><h3 id="3-2-系统流程图"><a href="#3-2-系统流程图" class="headerlink" title="3.2 系统流程图"></a>3.2 系统流程图</h3><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505000440.png" alt="img"></p><h3 id="3-3-系统运行的环境"><a href="#3-3-系统运行的环境" class="headerlink" title="3.3 系统运行的环境"></a>3.3 系统运行的环境</h3><p>​c++、glut环境下</p><hr><h2 id="4．各个功能模块的主要实现程序"><a href="#4．各个功能模块的主要实现程序" class="headerlink" title="4．各个功能模块的主要实现程序"></a>4．各个功能模块的主要实现程序</h2><h3 id="4-1-游戏引擎"><a href="#4-1-游戏引擎" class="headerlink" title="4.1 游戏引擎"></a>4.1 游戏引擎</h3><h4 id="4-1-1-游戏循环管理"><a href="#4-1-1-游戏循环管理" class="headerlink" title="4.1.1 游戏循环管理"></a>4.1.1 游戏循环管理</h4><p>我设置了一个glut定时器（glutTimerFunc）作为整个游戏循环的驱动，并在函数最后重新调用此方法，以实现系统循环，每次循环调用的时间为1ms。</p><pre class="line-numbers language-c++"><code class="language-c++">void update(int v){    //...    glutTimerFunc(tickTime, update, 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此函数中包含了图像重绘，调整窗口大小，敌人生成与基本实体的内部循环等游戏核心逻辑部分。</p><p>对于基本实体的内部循环，我创建了一个基类entity，所有需要在屏幕上显示的实体都必须继承自这个entity类。在类的构造函数中，我将此类实例加入entities链表。这个链表中包含所有游戏实体，方便遍历执行实体的更新与重绘操作。</p><pre class="line-numbers language-c++"><code class="language-c++">class entity{public:   pair<float, float> pos;   float hp;   float moveSpeed;   int ID;   EntityType type;   bool toDelete = false;   float checkRadius;   void virtual Draw();   virtual void Draw(pair<float, float> pos);   virtual void Update();   virtual void PhysicalCheck();   virtual void Check(entity* other);   virtual void OnCollispe(entity* other);   entity(){       ID = entities.size();       entities.push_back(this);       type = T_Untagged;   }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我将在<em>4.2**游戏玩法</em>中详细介绍这个类。在循环这一过程中，我会遍历entities这个类并逐一调用其update函数以实现基本实体的内部循环。</p><pre class="line-numbers language-c++"><code class="language-c++">for (int i = 0; i < entities.size(); i++){   entities[i]->Update();   if(entities[i]->toDelete)   {       entity *e = entities[i];       entities.erase(entities.begin() + i);       i--;   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2-图形渲染（使用OpenGL）"><a href="#4-1-2-图形渲染（使用OpenGL）" class="headerlink" title="4.1.2 图形渲染（使用OpenGL）"></a>4.1.2 图形渲染（使用OpenGL）</h4><p>在本游戏中，图形渲染依赖于游戏循环与刚才说的entity类。在循环中，我每帧调用glut重绘函数，并在myDisplay中清屏后遍历所有实体进行绘制。</p><pre class="line-numbers language-c++"><code class="language-c++">void myDisplay(){    if(GameState == Play || GameState == Over){        glClear(GL_COLOR_BUFFER_BIT);        for (int i = 0; i < entities.size(); i++)        {            if(entities[i]->type != T_StoreUI){                entities[i]->Draw();            }        }        glutSwapBuffers();    }    else if (GameState == Store)    {        glutSetWindow(storeWinId);        glClear(GL_COLOR_BUFFER_BIT);        for (int i = 0; i < uis.size(); i++)        {            uis[i]->Draw();        }        glutSwapBuffers();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在entity类中，我利用Draw()函数作为中介，在函数中进行内部存储坐标（世界坐标）到屏幕坐标的转换，并传入虚函数Draw(pair&lt;float, float&gt; pos)中方便子类直接在屏幕坐标的基础上进行个性化绘制。其中if保证了图像在其他窗口中也能按照世界坐标进行绘制。</p><pre class="line-numbers language-c++"><code class="language-c++">    void virtual Draw(){        pair<float, float> screenPos = world2WindowPos(pos);        if(glutGetWindow() == bossWinId){            screenPos = world2WindowPos(pos, {bossWindowPos[0], bossWindowPos[1]}, {bossWindowSize[0], bossWindowSize[1]});            //cout << screenPos.first << screenPos.second;        }        Draw(screenPos);    }    virtual void Draw(pair<float, float> pos) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于坐标转换，世界坐标以屏幕左下角为原点，而画面坐标以窗口右下角为原。我维护了两个窗口变量，分别记录了窗口的左上角的位置（相对于屏幕左上角）和窗口的大小，故画面坐标下的x即为世界坐标下的x减去窗口位置的x值，而画面坐标下的y即为世界坐标下的y减去窗口下方到屏幕下方的距离，即屏幕y大小减窗口y坐标减窗口y大小。若要反向求解只要将这个过程逆过来即可。</p><p>考虑到本游戏为多窗口游戏，在函数中，我将窗口坐标与大小设为可以传入的参数，以方便物体坐标在主游戏窗口以外的窗口中的计算。</p><pre class="line-numbers language-c++"><code class="language-c++">pair<float, float> world2WindowPos(pair<float, float> pos, pair<float, float> winpos = {windowPos[0], windowPos[1]}, pair<float, float> winsize = {windowSize[0], windowSize[1]}){    pos.first -= winpos.first;    pos.second = pos.second - (screenSize[1] - winpos.second - winsize.second);    return pos;}pair<float, float> window2WorldPos(pair<float, float> pos, pair<float, float> winpos = {windowPos[0], windowPos[1]}, pair<float, float> winsize = {windowSize[0], windowSize[1]}){    pos.first += winpos.first;    pos.second = pos.second + (screenSize[1] - winpos.second - winsize.second);    return pos;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-物理检测"><a href="#4-1-3-物理检测" class="headerlink" title="4.1.3 物理检测"></a>4.1.3 物理检测</h4><p>物理检测同样依赖于entity类。我在把所有实体的碰撞器模拟为一个圆的基础上实现碰撞。实体类中，我创建了Check虚方法定义该物体与其他物体的碰撞条件以方便子类个性化碰撞。而在基础的Check函数中，我将对比实体的物理检测半径与待检测实体的物理检测半径之和与它们之间的距离之差大小。如果检测半径之和小于距离则视为碰撞并调用中介方法<code>OnCollispe</code>。</p><p>在距离检测上，我写了Distance方法计算（根号下x差的平方加y差的平方）。</p><pre class="line-numbers language-c++"><code class="language-c++">float Distance(pair<float, float> a, pair<float, float> b){    return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在<code>PhysicalCheck()</code>方法中，我将遍历所有实体并通过Check函数检测碰撞。而<code>OnCollispe</code>函数则作为子类调用的接口，在检测到碰撞后将碰撞到的对象传递进去。</p><pre class="line-numbers language-c++"><code class="language-c++">    virtual void PhysicalCheck(){        for (auto &&en : entities)        {            if(en != this)                Check(en);        }    }    virtual void Check(entity* other){        if(Distance(pos, other->pos) <= checkRadius + other->checkRadius){            OnCollispe(other);        }    }    virtual void OnCollispe(entity* other){    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用时，要求手动将<code>PhysicalCheck</code>写在Update中，只对需要开启物理碰撞检测的实体开启碰撞，以达到减少运算的目的。例如：</p><pre class="line-numbers language-c++"><code class="language-c++">Player::Update(){    PhysicalCheck();    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-4-输入处理（键盘和鼠标）"><a href="#4-1-4-输入处理（键盘和鼠标）" class="headerlink" title="4.1.4 输入处理（键盘和鼠标）"></a>4.1.4 输入处理（键盘和鼠标）</h4><p>在输入上，我用了glut自带的输入方法。</p><pre class="line-numbers language-c++"><code class="language-c++">    glutKeyboardFunc(onKeyPress_Main);    glutKeyboardUpFunc(onKeyUp);    glutMouseFunc(mouseFunc_Main);    glutMotionFunc(OnMouseMove);    glutPassiveMotionFunc(OnMouseMove);    glutIgnoreKeyRepeat(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于键盘，由于<code>glutKeyboardFunc</code>中按键按下尤其是长按时往往只能获取到单个按键（后按下的按键）的状态，故我采用了<code>glutIgnoreKeyRepeat</code>来取消glut对长按检测的支持，并加入了<code>glutKeyboardUpFunc</code>检测按键抬起。我创建了四个变量表示按键的按下与抬起状态，并在<code>glutKeyboardFunc</code>和<code>glutKeyboardUpFunc</code>中赋值，以实现长按检测对多按键长按的支持。</p><pre class="line-numbers language-c++"><code class="language-c++">#pragma region 键鼠按键状态bool W_pressing;bool A_pressing;bool S_pressing;bool D_pressing;bool mouse_Pressing;pair<float, float> mousePos;pair<float, float> mousePos_Store;#pragma endregionvoid onKeyPress_Main(unsigned char key, int x, int y){    //GameState = Play;    if(key == 'a'){        //MoveWindow(Left, 5);        A_pressing = true;    }    if(key == 'd'){        //MoveWindow(Right, 5);        D_pressing = true;    }    if(key == 'w'){        //MoveWindow(Up, 5);        W_pressing = true;    }    if(key == 's'){        //MoveWindow(Down, 5);        S_pressing = true;    }    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（<code>onKeyUp</code>中同理检测按键并将对应变量赋值成false）</p><p>而对于鼠标，我采用了类似的方法创建鼠标状态变量并在<code>mouseFunc</code>方法中对其进行赋值。额外的，我还创建了<code>mousePos</code>变量获取鼠标的位置以方便实现其他功能时调用。</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505003142.gif" alt="img"></p><h3 id="4-2-游戏玩法："><a href="#4-2-游戏玩法：" class="headerlink" title="4.2 游戏玩法："></a>4.2 游戏玩法：</h3><h4 id="4-2-1-entity类"><a href="#4-2-1-entity类" class="headerlink" title="4.2.1 entity类"></a>4.2.1 entity类</h4><p>作为所有需显示实体的基类，该类中包含了所有需要的接口方法与属性。（见4.1.1中图）</p><p>pos中保存实体的世界坐标；hp保存实体的生命值；<code>moveSpeed</code>保存了实体的运动速度；ID保存了实体在entity数组中的位置；type保存了实体的类别；<code>toDelete</code>作为中介控制了实体的销毁。<code>checkRadiius</code>中则保存了实体的碰撞半径。</p><p>所有实体都需要指定一种类别（如不指定，则在基类构造函数中赋值为T_Untagged，以方便查询实体类别。</p><pre class="line-numbers language-c++"><code class="language-c++">enum EntityType{    T_Player,    T_Bullet,    T_Enemy,    T_Money,    T_StoreUI,    T_Untagged};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于删除实体，见4.1.1中图，我在需要删除实体时将其<code>toDelete</code>标记为true，并在主循环中统一删除，防止循环迭代过程中因为链表中节点变化产生错误或者漏计算。</p><h4 id="4-2-2-玩家移动和控制"><a href="#4-2-2-玩家移动和控制" class="headerlink" title="4.2.2 玩家移动和控制"></a>4.2.2 玩家移动和控制</h4><p>在绘制上，利用虚函数Draw获取屏幕坐标并通过课程中学到的八点画圆发绘制。</p><pre class="line-numbers language-c++"><code class="language-c++">void Draw(pair<float, float> screenPos){        glColor3f(1, 1, 1);        if(isInvicinble)    glColor3f(1, 0.8, 1);        glPointSize(3);        //cout << screenPos.first << " " << screenPos.second << " ";        circle(screenPos.first, screenPos.second, checkRadius);        DrawUI();    }void cirpot(int x0, int y0, int x, int y){    glBegin(GL_POINTS);        glVertex2i(x0 + x, y0 + y);        glVertex2i(x0 + y, y0 + x);        glVertex2i(x0 + x, y0 - y);        glVertex2i(x0 + y, y0 - x);        glVertex2i(x0 - x, y0 + y);        glVertex2i(x0 - y, y0 + x);        glVertex2i(x0 - x, y0 - y);        glVertex2i(x0 - y, y0 - x);    glEnd();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>玩家控制基于输入系统中创建的变量。这些变量决定玩家在x轴与y轴上的方向。注释内容为我原本想以加速度的方式给玩家一定的操作惯性，实际尝试后发现操作效果没有平动效果好，故予以删除。</p><pre class="line-numbers language-c++"><code class="language-c++">    void Move(){        //cout << pos.first << " " << pos.second << " ";        if(A_pressing){            //pos.first -= tickTime * moveSpeed;            direction.first = -1; // + direction.first * motivation; //direction.first -= accelerate;        }        else if(D_pressing){            //pos.first += tickTime * moveSpeed;            direction.first = 1;// + direction.first * motivation;           // direction.first += accelerate;        }else{            direction.first = 0;        }        if(W_pressing){            //pos.second += tickTime * moveSpeed;            direction.second = 1; // + direction.second * motivation; // direction.second -= accelerate;        }        else if(S_pressing){            //pos.second -= tickTime * moveSpeed;            direction.second = -1; // + direction.second * motivation; //direction.second += accelerate;        }else        {            direction.second = 0;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在移动时，我只需改变玩家的坐标，便能改变其在绘制时的位置。我将玩家的x坐标加上单位化后x轴上的方向乘以速度并乘上每次循环的时间加以矫正。</p><pre class="line-numbers language-c++"><code class="language-c++">pos.first += Normalize(direction).first * tickTime * moveSpeed;pos.second += Normalize(direction).second * tickTime * moveSpeed;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在单位化上，我写了函数Normalize，返回一个与传入向量同方向且大小为1的向量。</p><pre class="line-numbers language-c++"><code class="language-c++">pair<float, float> Normalize(pair<float, float> vec){    if(vec.first == 0 && vec.second == 0)        return vec;    float first = vec.first / sqrt(pow(vec.first, 2) + pow(vec.second, 2));    float second = vec.second / sqrt(pow(vec.first, 2) + pow(vec.second, 2));    return {first, second};}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改变完坐标后，还需检测玩家是否超出窗口范围，如果超出，则将玩家推回窗口内，并加上一定的offset，使玩家不会卡在屏幕边缘。</p><pre class="line-numbers language-c++"><code class="language-c++">        if(pos.first < windowPos[0])            pos.first = windowPos[0] + 5;        else if (pos.first > windowPos[0] + windowSize[0])        {            pos.first = windowPos[0] + windowSize[0] - 5;        }                if(pos.second > screenSize[1] - windowPos[1])             pos.second = screenSize[1] - windowPos[1] - 5;        else if (pos.second < screenSize[1] - (windowPos[1] + windowSize[1]))        {            pos.second = screenSize[1] - (windowPos[1] + windowSize[1]) + 5;        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505003511.gif" alt="img"></p><p>最后，在Update中调用Move函数即可实现玩家的移动控制。</p><h4 id="4-2-3-射击机制"><a href="#4-2-3-射击机制" class="headerlink" title="4.2.3 射击机制"></a>4.2.3 射击机制</h4><p>射击由player类中的Shoot函数与bullet类实现。首先，在player类中，我在Update函数中循环调用Shoot函数。当鼠标状态为按下并且可发射子弹时生成一个子弹实例，传入存在player中的属性参数，并将可发射子弹设为false，设置glut计时器调用静态函数enableShoot使在冷却时间过后可发射子弹重新回到true，为下一次发射做准备。</p><pre class="line-numbers language-c++"><code class="language-c++">    void Shoot(){        if(mouse_Pressing && shootable){            //cout << "shoot";            pair<float, float> worldMousePos = window2WorldPos(mousePos);            //cout <<"{player "<< mousePos.first << " " << mousePos.second << "}";            Bullet *b = new Bullet(this, pos.first, pos.second, Normalize({worldMousePos.first - pos.first, worldMousePos.second - pos.second}), 6, pushPower, strength, enemyPush);            //cout << b->pos.first << " " << b->pos.second << "   ";            glutTimerFunc(shootCD * 1000, enableShoot, ID);            shootable = false;        }    }static void enableShoot(int a){    player->shootable = true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​       而在bullet类中，还是使用虚函数Draw，绘制点状子弹。</p><pre class="line-numbers language-c++"><code class="language-c++">    void Draw(pair<float, float> screenPos){        glColor3f(1, 1, 1);        glPointSize(10);        glBegin(GL_POINTS);        glVertex2f(screenPos.first, screenPos.second);        glEnd();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类中属性分别存储子弹的前进方向，对窗口的推进力，对敌人的伤害，对敌人的击退力与子弹的所有者。属性均由构造函数传入赋值。此外，构造函数中还规定了子弹的类型。</p><pre class="line-numbers language-c++"><code class="language-c++">class Bullet : public entity{public:    pair<float, float> direction;    float windowPushPower;    float str;    float enemyPushPower;    entity *owner;        Bullet(entity* owner, int x, int y, pair<float, float> dir, float shootSpeed, float pushPower, float strength, float enemyPush){        this->owner = owner;        pos.first = x;        pos.second = y;        direction = dir;        type = T_Bullet;        moveSpeed = shootSpeed;        windowPushPower = pushPower;        checkRadius = 4;        str = strength;        enemyPushPower = enemyPush;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在移动方面，通过在Update函数中循环调用Move函数实现移动。与玩家移动相似的，函数将坐标加上单位化后的方向与速度和时间偏差量的乘积以实现坐标变化。并检测是否撞到窗口，如果撞到，施加力并调用Hit函数。</p><pre class="line-numbers language-c++"><code class="language-c++">    void virtual Move(){        pos.first += Normalize(direction).first * tickTime * moveSpeed;        pos.second += Normalize(direction).second * tickTime * moveSpeed;        if(pos.first < windowPos[0]){            MoveWindow(Left, windowPushPower);            Hit();        }else if (pos.first > windowPos[0] + windowSize[0])        {            MoveWindow(Right, windowPushPower);            Hit();        }        if(screenSize[1] - pos.second < windowPos[1]){            MoveWindow(Up, windowPushPower);            Hit();        }else if (screenSize[1] - pos.second > windowPos[1] + windowSize[1])        {            MoveWindow(Down, windowPushPower);            Hit();        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Hit函数中，我们将创建粒子效果并将实体的toDelete标记为true，等待在主循环中被删除。</p><pre class="line-numbers language-c++"><code class="language-c++">    void virtual Hit(){        CreateParticle();        toDelete = true;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505003832.gif" alt="img"></p><p>对敌人的碰撞则写在了enemy类中，将在4.2.4中介绍。</p><h4 id="4-2-4-敌人"><a href="#4-2-4-敌人" class="headerlink" title="4.2.4 敌人"></a>4.2.4 敌人</h4><p>本游戏中一共有三种敌人和一个boss，将在本点中详细介绍。关于敌人的生成，idleTime为没有的敌人生成的时间，会在Update中累加，当有敌人生成后会归零并继续累加。当它大于下一个敌人的生成时间后即进行生成。下次生成时间会随着游戏时间的增加变短同时有3-4s的随机浮动，以增强游戏性。</p><p>生成过程中，敌人只会生成在窗口视野范围外。先规定敌人生成处对于窗口的方向，再相应的用随机数随机出敌人的坐标。接着决定敌人的种类。当不满足boss时间的条件时，有50%概率生成敌人a，30%概率生成敌人b，20%概率生成敌人c。根据随机数确定后将坐标传入相应的敌人构造函数则为一次生成成功。</p><pre class="line-numbers language-c++"><code class="language-c++">    #pragma region 敌人生成        if(idleTime > nextEnemyTime && enemyNum < maxEneNum || enemyNum == 0){            //cout << "enemy";            idleTime = 0;                        nextEnemyTime = rand() % (int)(_nextEnemyTime) + 1.5;            enemyNum++;            MoveDirection dir = static_cast<MoveDirection>(rand() % 4);            float x, y;            if(dir == Left){                x = windowPos[0] - rand() % 100;                y = rand() % (int)screenSize[1];            }            if(dir == Right){                x = windowPos[0] + windowSize[0] + rand() % 100;                y = rand() % (int)screenSize[1];            }            if(dir == Up){                y = screenSize[1] - (windowPos[1] - rand() % 100);                x = rand() % (int)screenSize[0];            }            if(dir == Down){                y = screenSize[1] - (windowPos[1] + windowSize[1] + rand() % 100);                x = rand() % (int)screenSize[0];            }            //bossTime = 50;            if(bossTime < 50){                int enemyrand = rand() % 100;                if(enemyrand < 30){                    new Enemy2(x, y);                }else if(enemyrand < 80)                {                    new Enemy(x, y);                }else                {                    new Enemy3(x, y);                }            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>敌人中的enemy类，是第一种敌人，也是敌人的基类。绘制与之前的实体类似，绘制为正方形。在构造函数中设定类型和基础属性。</p><p>在移动上，普通情况下，敌人a移动方向为面向玩家，我将其速度限制为了其原速度和其与玩家距离*0.1中的最小值，以实现敌人在靠近玩家后会慢慢减速甚至停下。而<code>specialMovementTime</code>为敌人的击退、碰撞等特殊情况持续的帧数。当该值为正时，敌人会按照设定的特殊行动移动，并每帧减少该值。</p><pre class="line-numbers language-c++"><code class="language-c++">    void virtual Move(){        if(specialMovementTime > 0){            pos.first += Normalize(direction).first * tickTime * moveSpeed;            pos.second += Normalize(direction).second * tickTime * moveSpeed;            specialMovementTime--;        }        else        {            direction = {player->pos.first - pos.first, player->pos.second - pos.second};            moveSpeed = oriSpeed;            pos.first += Normalize(direction).first * tickTime * min(moveSpeed, (Length({player->pos.first - pos.first, player->pos.second - pos.second}) - 30) * 0.1f);            pos.second += Normalize(direction).second * tickTime * min(moveSpeed, (Length({player->pos.first - pos.first, player->pos.second - pos.second}) - 30) * 0.1f);        }     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在碰撞检测上，当检测到碰撞时，该函数会判断碰撞物的类别。如果同为敌人的实体进入碰撞范围，该实例会朝反方向进行一帧特殊行动，实现不与其他敌人重叠。当子弹进入碰撞范围，该实例会受到子弹的击退效果并减血，同时调用子弹的Hit函数销毁子弹。当碰撞为玩家时，给该实例一个大击退并使玩家扣血并获得1s的无敌效果，防止重复扣血。此时，玩家颜色显示为浅红色予以区分。</p><pre class="line-numbers language-c++"><code class="language-c++">    void OnCollispe(entity* other){        //cout << other->type;        if(other->type == T_Enemy){            if(specialMovementTime == 0){                direction = {pos.first - other->pos.first, pos.second - other->pos.second};                specialMovementTime = 1;            }        }else if (other->type == T_Bullet)        {            Bullet* b = static_cast<Bullet *>(other);            //cout << "hit";            if(b->owner == player){                if(specialMovementTime == 0){                    direction = {pos.first - other->pos.first, pos.second - other->pos.second};                    moveSpeed = b->enemyPushPower;                    specialMovementTime = 1;                }                //glutTimerFunc(1, recoverSpeed, ID);                hp -= b->str;                b->Hit();            }        }else if(other->type == T_Player){            if(specialMovementTime == 0){                direction = {pos.first - other->pos.first, pos.second - other->pos.second};                moveSpeed = 15;                specialMovementTime = 5;            }            //cout << "player";            if(!player->isInvicinble){                player->health--;                player->isInvicinble = true;                glutTimerFunc(player->invicinbleTime * 1000, Player::disinvicinble, player->ID);            }                    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Update中循环检测当hp&lt;=0时敌人死亡，依照玩家的掉落率属性生成对应数量的金币，产生粒子效果并将自身标记删除。</p><pre class="line-numbers language-c++"><code class="language-c++">    void Update(){        if(hp <= 0){            int moneyNum = player->moneyRate + rand() % 10 - 5;            for (int i = 0; i < moneyNum; i++)            {                new Money(pos);            }            CreateParticles(rand() % 3 + 6, pos, 0.7, 0.7, 0.1);            toDelete = true;            enemyNum--;        }        PhysicalCheck();        Move();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505004115.gif" alt="img"></p><p>敌人b为敌人a子类，重写了Draw函数和Update函数以实现颜色与粒子颜色上的区分。此外，还对Move函数进行了重写。敌人b有Attack和Search两种状态。当离玩家距离大于攻击距离时，敌人进入搜索状态并不断向玩家靠近。当距离小于搜索距离并且攻击冷却已结束时，敌人进入攻击状态，后退一小段距离进行缓冲，然后向玩家方向冲刺并释放粒子，冲刺过程中不改变方向。冲刺结束后回到搜索状态，等待冷却结束进行下一次攻击。</p><pre class="line-numbers language-c++"><code class="language-c++">            if(curState == Search){                direction = {player->pos.first - pos.first, player->pos.second - pos.second};                moveSpeed = oriSpeed;                pos.first += Normalize(direction).first * tickTime * min(moveSpeed, (Length({player->pos.first - pos.first, player->pos.second - pos.second}) - 30) * 0.1f);                pos.second += Normalize(direction).second * tickTime * min(moveSpeed, (Length({player->pos.first - pos.first, player->pos.second - pos.second}) - 30) * 0.1f);                if(attackCounter > 0)                    attackCounter -= tickTime;                if(Distance(player->pos, pos) < searchRange && attackCounter <= 0){                    attackCounter = attackCD;                    attackDiatance = toattackDiatance;                    curState = Attack;                }            }else if (curState == Attack)            {                if(attackCounter > 0){                    attackCounter -= tickTime;                    direction = {pos.first - player->pos.first, player->pos.second - pos.second};                    pos.first += Normalize(direction).first * tickTime * readySpeed;                    pos.second += Normalize(direction).second * tickTime * readySpeed;                    oriPos = pos;                    //cout << attackCounter;                    direction = {player->pos.first - pos.first, player->pos.second - pos.second};                }                   else                {                    moveSpeed = attackSpeed;                    pos.first += Normalize(direction).first * tickTime * attackSpeed;                    pos.second += Normalize(direction).second * tickTime * attackSpeed;                    attackDiatance -= Distance(pos, oriPos);                    if(rand() % 2 == 1)                        new Particle(pos, {-direction.first + rand() % 20 - 10, -direction.second + rand() % 20 - 10}, 20, 0.7, 0.1, 0.7);                    oriPos = pos;                    if(attackDiatance <= 0){                        curState = Search;                        attackCD = attackCold;                    }                }            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505004218.gif" alt="img"></p><p>敌人c与敌人b类似，也继承自enemy类。搜索状态下靠近玩家，攻击状态下停止移动并持续对玩家发射子弹，直到玩家离开攻击范围，离开后再次进入搜索状态。子弹继承自bullet类，玩家类中检测碰撞并判断子弹所有者，如为敌人则进行扣血。此外，敌人子弹对窗口没有推动作用。</p><pre class="line-numbers language-c++"><code class="language-c++">        if(Distance(player->pos, pos) > outRange && curState == Attack)            curState = Search;        if(Distance(player->pos, pos) < searchRange && curState == Search)            curState = Attack;............            direction = {player->pos.first - pos.first, player->pos.second - pos.second};            if(curState == Search){                moveSpeed = oriSpeed;                pos.first += Normalize(direction).first * tickTime * min(moveSpeed, (Length({player->pos.first - pos.first, player->pos.second - pos.second}) - 30) * 0.1f);                pos.second += Normalize(direction).second * tickTime * min(moveSpeed, (Length({player->pos.first - pos.first, player->pos.second - pos.second}) - 30) * 0.1f);            }else if (curState == Attack)            {                if(attackCounter < 0){                    EnemyBullet* b = new EnemyBullet(this, pos.first, pos.second, direction, 1, 0, 1, 10, 0.1, 0.7, 0.7);                    attackCounter = attackCD;                }else                {                    attackCounter -= tickTime;                }                            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505004344.gif" alt="img"></p><h4 id="4-2-5-boss"><a href="#4-2-5-boss" class="headerlink" title="4.2.5 boss"></a>4.2.5 boss</h4><p>boss也继承自enemy类，当bossTime计数到达一定时间后便生成boss，并创建新窗口。boss不会移动，玩家需利用推墙到达boss所在处并攻击boss。伤害到达一定量后便会转移。boss发射激光，由两道警告光和一道真伤光组成，光柱由一系列enemyBullet构成，警告光伤害为0，颜色更暗。</p><pre class="line-numbers language-c++"><code class="language-c++">            else if(attackReadyCounter <= 0){                attackTimeCounter -= tickTime;                if(attackTimeCounter <= 0){                    if(bList.size() == 0){                        for (int i = 0; i < 1000; i++)                        {                            EnemyBullet* b = new EnemyBullet(this, pos.first + Normalize(direction).first * i, pos.second + Normalize(direction).second * i, {}, 0, 0, 1, 0, 1, 0, 0, false);                            bList.push_back(b);                            attackTimeCounter = attackTimeCD;                        }                    }else{                        for (auto &&b : bList)                        {                            b->toDelete = true;                        }                        bList = vector<Bullet *>();                        curState = Idle;                    }                }                            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505004438.gif" alt="img"></p><h4 id="4-2-6-商店"><a href="#4-2-6-商店" class="headerlink" title="4.2.6 商店"></a>4.2.6 商店</h4><p>商店由<code>ChooseItem</code>和<code>StoreManager</code>组成，其中<code>StoreManager</code>采用了单例模式方便调用。<code>ChooseItem</code>为一项可以升级的属性，保存了显示字符、需要花费、位置坐标和方法接口等。此外，类中还重写了<code>PhysicalCheck</code>函数实现鼠标选中与点击响应。</p><pre class="line-numbers language-c++"><code class="language-c++">void ChooseItem::PhysicalCheck(){    {        //cout << mousePos_Store.first << ' ' << mousePos_Store.second << endl;        //cout << isMouseUp;        if(leftDown.first < mousePos_Store.first && mousePos_Store.first < rightUp.first && leftDown.second < mousePos_Store.second && mousePos_Store.second < rightUp.second && player->money >= cost){            isMouseUp = true;        }else        {            isMouseUp = false;        }                if(isMouseUp && mouse_Pressing){            isChosen = true;        }        if(isChosen && !mouse_Pressing){            if(isMouseUp){                //执行                if(itemFunc != NULL){                    itemFunc();                }                player->money -= cost;                static_cast<ChooseItem*>(entities[UID])->cost += costA;                StoreManager::instance()->RefreshStore();                StoreManager::instance()->ShowItems();                //toDelete = true;                                isChosen = false;            }            else            {                isChosen = false;            }         }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>StoreManager</code>中初始化了所有<code>ChooseItem</code>，每次打开商店时刷新并复制一份随机选中的<code>ChooseItem</code>显示。商店显示与实体类似，但仅遍历<code>uis</code>链表。购买一项后使储存的<code>ChooseItem</code>花费增加、清空链表并再次生成item。</p><pre class="line-numbers language-c++"><code class="language-c++">    void ShowItem(pair<float, float> ld, pair<float, float> ru){                leftDown = ld;        rightUp = ru;        isMouseUp = false;        isChosen = false;        //cout << entities.size();        ChooseItem *copy = new ChooseItem(*this);        copy->ID = entities.size();        copy->UID = ID;        uis.push_back(copy);        entities.push_back(copy);        //cout << entities.size();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505004617.gif" alt="img"></p><h4 id="4-2-7-金币"><a href="#4-2-7-金币" class="headerlink" title="4.2.7 金币"></a>4.2.7 金币</h4><p>金币被生成后会向上浮动一段距离，使画面更灵动。当金币与玩家的距离小于玩家的拾取范围时，金币会自动靠近吸附于玩家。</p><pre class="line-numbers language-c++"><code class="language-c++">    void Move(){        //cout << Distance(pos, player->pos);        if(Distance(pos, player->pos) < player->pickRange){            direction = {player->pos.first - pos.first, player->pos.second - pos.second};            pos.first += Normalize(direction).first * tickTime * moveSpeed;            pos.second += Normalize(direction).second * tickTime * moveSpeed;        }        else{            if(distance > 1){                pos.second += tickTime * moveSpeed * distance * 0.02;                distance -= Distance(pos, oriPos);            }            else if(fallDistance < -1){                pos.second -= tickTime * fallSpeed;                fallDistance += Distance(pos, oriPos);            }            oriPos = pos;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240505004644.gif" alt="img"></p><h4 id="4-2-8-粒子系统"><a href="#4-2-8-粒子系统" class="headerlink" title="4.2.8 粒子系统"></a>4.2.8 粒子系统</h4><p>粒子系统由Particle类组成。可直接调用<code>CreateParticle</code>传入个数，位置，颜色和大小创造粒子。其中，x、y上的方向均为-10<del>10中的随机数。理论上来说取-1</del>1之间的任意随机实数即可实现所有方向上的随机，但考虑到我取随机数的方法没法得到小数，故改为使用-10~10中的随机数，在运算时单位化以实现任意方向上的随机。</p><pre class="line-numbers language-c++"><code class="language-c++">void CreateParticles(int n, pair<float, float> pos, float r, float g, float b, float size = 2){    for (int i = 0; i < n; i++)    {        //（-10 - 10） （5， 5）        //（5/sqrt（50））        new Particle(pos, {rand() % 21 - 10, rand() % 21 - 10}, rand() % 15 + 60, r, g, b, size);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>粒子被创建后即会朝着固定方向移动一定距离，当满足距离条件后即将自己销毁。</p><pre class="line-numbers language-c++"><code class="language-c++">    void Move(){        //cout << direction.first << " " << direction.second;        if(direction.first == 0 && direction.second == 0)            toDelete = true;        pos.first += Normalize(direction).first * tickTime * moveSpeed;        pos.second += Normalize(direction).second * tickTime * moveSpeed;        distance -= Distance(pos, oriPos);        if(distance <= 0){            toDelete = true;        }        oriPos = pos;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，在绘制时，我使粒子大小随着走过的路程变大而减小，使粒子更有散开的氛围感。</p><pre class="line-numbers language-c++"><code class="language-c++">    void Draw(pair<float, float> screenPos){        glColor3f(r, g, b);        glPointSize(oriSize * distance * 0.05);        glBegin(GL_POINTS);        glVertex2f(screenPos.first, screenPos.second);        glEnd();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-用户界面"><a href="#4-3-用户界面" class="headerlink" title="4.3 用户界面"></a>4.3 用户界面</h3><h4 id="4-3-1-窗口"><a href="#4-3-1-窗口" class="headerlink" title="4.3.1 窗口"></a>4.3.1 窗口</h4><p>在Update函数中，我实时修改窗口的属性，使其随我设定的窗口大小与位置变量改变而改变。逻辑中，我只需要改变变量的大小，就能使窗口每帧缩小。</p><pre class="line-numbers language-c++"><code class="language-c++">#pragma region 窗口移动enum MoveDirection{    Left,    Right,    Up,    Down,    Center};float last[4];void MoveWindow(MoveDirection dir, float value){    if(value + last[dir] > 3){        last[dir] += value - 3;        value = 3;    }    switch (dir)    {    case Left:        windowPos[0] -= value;        windowSize[0] += value;        break;    case Right:        windowSize[0] += value;        break;    case Up:        windowPos[1] -= value;        windowSize[1] += value;        break;    case Down:        windowSize[1] += value;        break;    default:        break;    }}#pragma endregion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，为了使窗口缓动，当窗口小于一定范围后，我会使窗口变化速度减缓直至趋近于0，当大于一定范围时，则会使窗口增大速度趋于0。</p><pre class="line-numbers language-c++"><code class="language-c++">void MoveWindow2Center(float value){    float valX = min(value, (windowSize[0] - 250) * 0.01f);    if(windowSize[0] >= 600)        valX = max(windowSize[0] * 0.001f, valX);    float valY = min(value, (windowSize[1] - 250) * 0.005f);    if(windowSize[1] >= 700)    {        valY = max(windowSize[1] * 0.0005f, valY);    }    MoveWindow(Left, -valX);    MoveWindow(Right, -valX);    MoveWindow(Up, -valY);    MoveWindow(Down, -valY);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="5．课程设计总结与体会"><a href="#5．课程设计总结与体会" class="headerlink" title="5．课程设计总结与体会"></a>5．课程设计总结与体会</h2><p>通过本次课程设计，我对游戏开发有了更深入的理解和实践。在游戏架构设计上，我学会了如何合理划分功能模块，使得代码结构清晰，便于维护和扩展。在游戏引擎的实现上，我掌握了OpenGL的基本使用方法，了解了如何在游戏循环中统一管理操作，以及如何处理输入输出和图形渲染。在游戏玩法的开发过程中，我学会了如何设计敌人的行为模式和生成机制，以增加游戏的趣味性和挑战性。此外，我还学会了如何设计和实现用户界面，使得游戏更加友好和易于操作。</p><p>在本次课程设计中，我遇到了一些困难和挑战。例如，在游戏循环管理上，我最初使用的是glutIdleFunc，后来发现这种方式并不能很好地满足我的需求，于是改为使用glutTimerFunc。在处理输入输出时，我也遇到了一些问题，例如如何正确处理键盘和鼠标事件。通过查阅资料和不断尝试，我最终成功解决了这些问题。</p><p>通过本次课程设计，我不仅提高了自己的编程能力和解决问题的能力，还加深了对游戏开发的理解。我认识到，游戏开发不仅仅是编写代码，还需要进行需求分析、模块划分、界面设计等多方面的考虑。此外，我也体会到了团队合作的重要性，因为在开发过程中，我与其他同学进行了交流和合作，共同解决问题，这使得我受益匪浅。</p><p>总之，本次课程设计使我收获颇丰，不仅提高了我的技术能力，还培养了我的团队合作意识和解决问题的能力。我相信，在今后的学习和工作中，我会继续努力，将所学知识运用到实际项目中，不断提高自己的综合素质。</p><p><a href="https://github.com/mashimarokumo/CG/releases/download/v1.0.0/final.exe">试玩地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Study </tag>
            
            <tag> Game Create </tag>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅2022机器学习笔记</title>
      <link href="/posts/li-hong-yi-2022-ji-qi-xue-xi-bi-ji/"/>
      <url>/posts/li-hong-yi-2022-ji-qi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习方法"><a href="#机器学习方法" class="headerlink" title="机器学习方法"></a>机器学习方法</h2><ol><li><p>预测模型</p><p>猜测预测数据与已知数据的关系($y = b + wx$)</p></li><li><p>定义Loss</p><p>传入模型作为参数，平均预算误差的绝对值作为输出(MAE)</p><p>​或误差平方的平均值(MSE)</p></li><li><p>找最佳化数值</p></li></ol><h3 id="修改模型（sigmoid）"><a href="#修改模型（sigmoid）" class="headerlink" title="修改模型（sigmoid）"></a>修改模型（sigmoid）</h3><ol><li><p>考虑w</p><p>$y = b +\displaystyle\sum_{j}w_jx$</p></li><li><p>考虑模型</p></li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170845.png" alt="image-20231111154158171" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170855.png" alt="image-20231111154613377" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170903.png" alt="image-20231111154729633" style="zoom:33%;">$$y = b + \displaystyle\sum_i c_i sigmoid(b_i + \sum_jw_{ij}x_j)$$<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170911.png" alt="image-20231111160431657" style="zoom:33%;"><img src="G:/study/others/MachineLearning/pics/机器学习/image-20231111160654332.png" alt="image-20231111160654332" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170917.png" alt="image-20231111160818625" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170923.png" alt="image-20231111161049073" style="zoom:33%;">$$y = b+ \boldsymbol c^T\sigma(\boldsymbol b+\boldsymbol w\boldsymbol x)$$<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170928.png" alt="image-20231111161822839" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170934.png" alt="image-20231111162554616" style="zoom:33%;"><p>$\eta$为自己设定的leaning rate</p><p>实际操作：B(batch size)为自己决定的参数量，将N个参数分为N/B份，每次拿一个B进行一次数值更新(update)，用光所有B为一次epoch</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170942.png" alt="image-20231111162959893" style="zoom:33%;"><h3 id="模型修改2-ReLU"><a href="#模型修改2-ReLU" class="headerlink" title="模型修改2(ReLU)"></a>模型修改2(<code>ReLU</code>)</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170948.png" alt="image-20231111163739389" style="zoom:33%;"><p>两个<code>ReLU</code>可以替换一个sigmoid，故可将原式改为$y = b+\displaystyle\sum_{2i}c_imax(0, b_i+\sum_jw_{ij}x_j)$  </p><p>这样的函数称为<strong>激活函数</strong></p><h3 id="进一步修改（增加层数）"><a href="#进一步修改（增加层数）" class="headerlink" title="进一步修改（增加层数）"></a>进一步修改（增加层数）</h3><p>对得到的数据a再进行$\sigma$操作得到$a^,$ 不断重复</p><p>问题：过拟合</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170955.png" alt="image-20231111164754541" style="zoom:33%;"><img src="G:\study\others\MachineLearning\pics\机器学习\image-20231111225724229.png" alt="image-20231111225724229"></p><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a><code>Pytorch</code></h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171002.png" alt="image-20231111225853587" style="zoom:33%;"><h3 id="生成tensor"><a href="#生成tensor" class="headerlink" title="生成tensor"></a>生成tensor</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171021.png" alt="image-20231112232309333" style="zoom:33%;"><h3 id="tensor运算操作"><a href="#tensor运算操作" class="headerlink" title="tensor运算操作"></a>tensor运算操作</h3><ul><li><p>减少长度squeeze</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171029.png" alt="image-20231112232358180" style="zoom:33%;"></li><li><p>升维<code>unsqueeze</code></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171131.png" alt="image-20231112232736627" style="zoom:33%;"></li><li><p>转置transpose</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171137.png" alt="image-20231112233001331" style="zoom:33%;"></li><li><p>组合cat</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171142.png" alt="image-20231112233202203" style="zoom:33%;"></li><li><p>其他</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171149.png" alt="image-20231112233247391" style="zoom:25%;"></li></ul><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171153.png" alt="image-20231112233517372" style="zoom:33%;"><p>可用torch.cuda.is_available() 检测是否存在可用gpu</p><h3 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h3><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171159.png" alt="image-20231112234244805" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171206.png" alt="image-20231112234503487"></p><h3 id="数据读取（data）"><a href="#数据读取（data）" class="headerlink" title="数据读取（data）"></a>数据读取（data）</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171216.png" alt="image-20231112234244805" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171222.png" alt="image-20231112234943610" style="zoom:33%;"><p>shuffle:是否乱序</p><h3 id="建立神经网络"><a href="#建立神经网络" class="headerlink" title="建立神经网络"></a>建立神经网络</h3><ul><li>线性模型</li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171230.png" alt="image-20231112235305657" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171238.png" alt="image-20231112235335026" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171244.png" alt="image-20231112235626950" style="zoom:33%;"><ul><li><p>激活函数</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171250.png" alt="image-20231112235701333" style="zoom:33%;"></li></ul><h3 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h3><p>MSE</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171256.png" alt="image-20231112235816607" style="zoom:33%;"><h3 id="产生神经网络"><a href="#产生神经网络" class="headerlink" title="产生神经网络"></a>产生神经网络</h3><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171301.png" alt="image-20231113000036718" style="zoom: 25%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171308.png" alt="image-20231113000054359" style="zoom:25%;"></p><p>sequential中依次放入不同层的函数</p><h3 id="更新模型（optimization）"><a href="#更新模型（optimization）" class="headerlink" title="更新模型（optimization）"></a>更新模型（optimization）</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171314.png" alt="image-20231113000412683" style="zoom:33%;"><p><code>lr</code>为learning rate</p><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><ul><li><p>准备</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171321.png" alt="image-20231113000607390" style="zoom:33%;"></li><li><p>一个epoch的训练</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171327.png" alt="image-20231113000756919" style="zoom:33%;"></li><li><p>模型评估</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171334.png" alt="image-20231113001259335" style="zoom:33%;"></li><li><p>测试组</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171341.png" alt="image-20231113001341676" style="zoom:33%;"></li></ul><h3 id="储存-加载模型"><a href="#储存-加载模型" class="headerlink" title="储存/加载模型"></a>储存/加载模型</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171346.png" alt="image-20231113001604544" style="zoom: 33%;"><h2 id="代码优化方法"><a href="#代码优化方法" class="headerlink" title="代码优化方法"></a>代码优化方法</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171353.png" alt="image-20231113165806187" style="zoom:33%;"><h3 id="training-loss过大"><a href="#training-loss过大" class="headerlink" title="training loss过大"></a>training loss过大</h3><h4 id="模型太过简单-重新设计模型"><a href="#模型太过简单-重新设计模型" class="headerlink" title="模型太过简单 重新设计模型"></a>模型太过简单 重新设计模型</h4><p>解决方法：</p><ul><li>加入更多features</li><li>增加neuro/layer</li></ul><h4 id="optimization不够好"><a href="#optimization不够好" class="headerlink" title="optimization不够好"></a>optimization不够好</h4><p>判断方法：比较不同模型</p><h3 id="testing-loss过大"><a href="#testing-loss过大" class="headerlink" title="testing loss过大"></a>testing loss过大</h3><h4 id="overfitting过拟合"><a href="#overfitting过拟合" class="headerlink" title="overfitting过拟合"></a>overfitting过拟合</h4><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171406.png" alt="image-20231113170659159" style="zoom:33%;"><p>解决方法：</p><ul><li><p>增加训练资料</p></li><li><p>data augmentation</p><p>用自己对资料的理解合理增加训练资料</p></li><li><p>减小模型弹性</p><ul><li>减少神经数目、共用参数</li><li>减少features</li><li>early stopping</li><li>regularization</li><li>dropout</li></ul></li></ul><h2 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171412.png" alt="image-20231113205032580" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171420.png" alt="image-20231113205611772" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171430.png" alt="image-20231113205819948" style="zoom:33%;"><p>反推出偏微分</p><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>除了局部最小 gradient 为零(critical point)还可能因为处于<strong>鞍点</strong></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171438.png" alt="image-20231113172619170" style="zoom:33%;"><p>鉴别处于鞍点还是局部最小点：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171445.png" alt="image-20231113191019521" style="zoom:33%;"><p>处于critical point时g为0，故可以通过红色项判断图像趋势</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171450.png" alt="image-20231113191441848" style="zoom:33%;"><p>eigen value：特征值H为由L的二次微分组成的矩阵</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171458.png" alt="image-20231113192240520" style="zoom:33%;"><p>通过H也可求出鞍点时能让Loss变小的方向（$\theta^,\rightarrow\theta$)</p><h2 id="Batch-Momentum"><a href="#Batch-Momentum" class="headerlink" title="Batch &amp;  Momentum"></a>Batch &amp;  Momentum</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171504.png" alt="image-20231113193601124" style="zoom:33%;"><p>由于GPU平行计算，大batch效率可能会高于小batch</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171512.png" alt="image-20231113193750843" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171516.png" alt="image-20231113194701311" style="zoom:33%;"><p><strong>Momentum</strong></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171522.png" alt="image-20231113195334045" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171529.png" alt="image-20231113195924574"></p><h2 id="自动调整学习率"><a href="#自动调整学习率" class="headerlink" title="自动调整学习率"></a>自动调整学习率</h2><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171539.png" alt="image-20231113195924574"></p><p>大体思想：在较平滑的地方lr应较大 反之则较小</p><ul><li>Adagard</li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171544.png" alt="image-20231113200528507" style="zoom:33%;"><ul><li><p>RMSProP</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171548.png" alt="image-20231113200941873" style="zoom:33%;"></li></ul><p>最常用的optimization策略：Adam（RMSProp + Momentum）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171553.png" alt="image-20231113202456036" style="zoom:33%;"><p>Learning Rate Scheduling:</p><p>由于$\sigma$随着时间累计，在g变化较小的地方步伐减小，可能出现朝着之前记录的无关方向暴增的现象，故</p><ul><li><p>Learning Rate Decay:</p><p>将$\eta$设定为随时间减小的变量</p></li><li><p>Warm Up:</p><p>使$\eta$先变大后变小</p></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>输出形式为向量，与标准做Loss前(称为logit)要先用Soft-max函数归一化（同时使大小差距更大</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171559.png" alt="image-20231113203134896" style="zoom:33%;"><p>而如果只有两种分类一般直接套用sigmoid（实质等价）（判别与生成）</p><p><strong>cross-entropy</strong></p><p>可以理解为计算两组概率之间的相似度</p><p>** 在pytorch中使用cross-entropy时自动对最后一层调用soft-max</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171603.png" alt="image-20231113203916492" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171608.png" alt="image-20231113204117032" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171614.png" alt="image-20231113212641390" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171620.png" alt="image-20231113213323356" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171625.png" alt="image-20231113213521316" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171632.png" alt="image-20231113213458428" style="zoom:33%;"><p>改进：</p><p>共用同一个$\sum$参数</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171638.png" alt="image-20231114160201310" style="zoom:33%;"><p>分界线变为直线，称这种分类模型为linear model</p><p>三步骤总结：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171642.png" alt="image-20231114160651106" style="zoom:33%;"><h2 id="逻辑回归（判别）"><a href="#逻辑回归（判别）" class="headerlink" title="逻辑回归（判别）"></a>逻辑回归（判别）</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171647.png" alt="image-20231114162117186" style="zoom:33%;"><p>在共享$\sum$的前提下 经计算可将$P_{w,b}(C_1|x)$化为$f_{w,b}(x)=\sigma(wx+b)$</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171652.png" alt="image-20231114164522109" style="zoom:50%;"><p>step2中不使用square error的原因：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171658.png" alt="image-20231114164928852" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171703.png" alt="image-20231114165052873" style="zoom:33%;"><p>判别模型与生成模型找出的w与b并非同一组</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171709.png" alt="image-20231114165655869" style="zoom:33%;"><p>由于生成模型有对模型的先行猜测，一般来说判别模型优于生成模型，在少数据量的环境下生成模型也可能占优势</p><p>即判别模型受data影响大，生成模型熟data影响小</p><ul><li><p>为什么需要一个好的Training Data：</p><p>（$\sigma$为自己设定的理想差值）</p></li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171714.png" alt="image-20231115190022574" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171720.png" alt="image-20231115191455687" style="zoom:33%;"><p>故增加N（sample出来的训练资料数）或减小H（取参范围）可以减小训练资料和实际资料的差距</p><p>但是H不能太小</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171725.png" alt="image-20231115192124449" style="zoom:33%;"><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>很有趣！</p><p>专为影像识别设计的学习算法 特点：1.一个特征只要看很小部分就能知道 2.同一个特征可能出现在不同位置</p><p>先将图片缩放为统一大小，再用filter进行卷积操作</p><ol><li>经典设置</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171730.jpg" alt="img" style="zoom: 33%;"><ol start="2"><li>共享参数</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171735.jpg" alt="img" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171738.jpg" alt="img" style="zoom:33%;"><p>pooling 在横纵轴拿掉一些像素， 识别出的物体不变 降低计算量，但减少精确度</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171743.jpg" alt="img" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171747.jpg" alt="img" style="zoom:33%;"><p>为什么deep learning能减少参数量与运算速度</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171753.jpg" alt="img" style="zoom:33%;"><p>也可用于alphago（满足最开始的两个特征 去除pooling提高精确度</p><p>问题：无法处理缩放、旋转图片</p><h3 id="spatial-transformer"><a href="#spatial-transformer" class="headerlink" title="spatial transformer"></a>spatial transformer</h3><p>对原图片进行平移、旋转、缩放等操作，再投入CNN模型方便识别</p><h2 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h2><p>问题：目前输入只能是一维向量，且长度不能改变</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171759.png" alt="image-20231118162347705" style="zoom:33%;"><p>经过self-attention的向量是考虑了所有向量后生成的新向量</p><p>如何产生新向量？</p><ol><li>判断一个向量与其他各向量之间的关联性</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171804.png" alt="image-20231118162756960" style="zoom:33%;"><p>dot-product：</p><p>常用的关联性计算方式 关联性越大值越大 其中soft-max可改为任意激活方程 常用soft-max</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171809.png" alt="image-20231118164003817" style="zoom:33%;"><p>再将结果乘上矩阵得到第一个向量</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171814.png" alt="image-20231118164220097" style="zoom:33%;"><p>其中$W^v,W^q,W^q$均靠机器学习得到</p><p>写成矩阵形式：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171819.png" alt="image-20231118165442577" style="zoom:33%;"><h3 id="multi-head"><a href="#multi-head" class="headerlink" title="multi head"></a>multi head</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171824.png" alt="image-20231118192616797" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171829.png" alt="image-20231118192638718" style="zoom:33%;"><p>缺点：feature里完全未包含位置资讯</p><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171835.png" alt="image-20231118193109818" style="zoom:33%;"><p>将不同的$e^i$加到$a^i$前面 e可由特定函数求出，也可由学习得出</p><p>现有的一些positional encoding方法</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171842.png" alt="image-20231118193321083" style="zoom:33%;"><h3 id="truncated-self-attention"><a href="#truncated-self-attention" class="headerlink" title="truncated self-attention"></a>truncated self-attention</h3><p>由于有时输入向量长度过大（如语音识别等 经过self-attention时可以不看所有向量，而只看前后数个</p><h3 id="for-image"><a href="#for-image" class="headerlink" title="for image"></a>for image</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171847.png" alt="image-20231118194326843" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171903.png" alt="image-20231118194349227" style="zoom:33%;"><p>实际上，CNN为self-attention的特例</p><p>self-attention的filter范围实际通过学习决定，限制更少，弹性更大，更容易过拟合，需要的资料量更大</p><p>CNN的filter范围由人为决定，限制更多，弹性更小，小资料量下表现更好</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171908.png" alt="image-20231118195157019" style="zoom:33%;"><h3 id="对比RNN"><a href="#对比RNN" class="headerlink" title="对比RNN"></a>对比RNN</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171913.png" alt="image-20231118195616416" style="zoom:33%;"><p>RNN：</p><ol><li>只考虑当前向量之前的向量（存在双向RNN 故可忽略</li><li>新参数依赖之前计算的参数，各个参数不能平行计算。</li><li>参数关联性更难计算，最后一个参数获得第一个参数的关联需将第一个参数一直存在内存中</li><li>参数顺序有关</li></ol><h3 id="for-graph（a-kind-of-GNN）"><a href="#for-graph（a-kind-of-GNN）" class="headerlink" title="for graph（a kind of GNN）"></a>for graph（a kind of GNN）</h3><p>关联性已知，计算关联性与参数时可以指考虑相连的节点</p><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>无关：将词汇表示为vector的方法</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171918.png" alt="image-20231118200806969" style="zoom:33%;"><h3 id="Elman-Network"><a href="#Elman-Network" class="headerlink" title="Elman Network"></a>Elman Network</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171923.png" alt="image-20231118201139517" style="zoom:33%;"><p>例子：</p><p>注：三次为同一个network</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171930.png" alt="image-20231118201600461" style="zoom:33%;"><h3 id="Jordan-Network"><a href="#Jordan-Network" class="headerlink" title="Jordan Network"></a>Jordan Network</h3><p>将output存入memory，并在下个向量的hidden layer输入</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171935.png" alt="image-20231118201951393" style="zoom:33%;"><h3 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h3><p>同时train一个正向、逆向的network，将两者hidden layer参数结合考虑再投入output layer</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171940.png" alt="image-20231118202352070" style="zoom:33%;"><h3 id="Long-Short-term-Memory（LSTM）"><a href="#Long-Short-term-Memory（LSTM）" class="headerlink" title="Long Short-term Memory（LSTM）"></a>Long Short-term Memory（LSTM）</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171945.png" alt="image-20231119135524436" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171952.png" alt="image-20231119135602896" style="zoom:33%;"><p>四个input中输入的都是同一参数值乘上不同的weight</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171957.png" alt="image-20231119140623182" style="zoom:33%;"><p>故lstm network需要的参数量是普通network的四倍</p><p>矩阵形式：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420172003.png" alt="image-20231119141213464" style="zoom:33%;"><p>真正的LSTM：</p><p>（在Keras中，这个结构叫做LSTM，上面的结构为SimpleRNN， 此外，还有个GRU的简化版，只有两个门，少了1/3的参数，不容易过拟合</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420172040.png" alt="image-20231119141515123"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101笔记</title>
      <link href="/posts/games101-bi-ji/"/>
      <url>/posts/games101-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>向量的点乘：判断是否为同一方向</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165203.png" alt="image-20230906210147863" style="zoom:33%;"><p>点乘大于0则为同一半朝向，小于0则为反朝向</p><p>向量的叉乘：判断里外关系</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165213.png" alt="image-20230906210236659" style="zoom: 50%;"><p>各顶点出发到目标点与同点出发边向量相乘，均大于零或均小于零则为在内 否则在外</p><hr><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li><p>缩放图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165216.png" alt="image-20230906210805182" style="zoom: 80%;"></li><li><p>反转图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165219.png" alt="image-20230906210905671" style="zoom:80%;"></li><li><p>旋转图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170202.png" alt="image-20230906210657531" style="zoom:80%;"></li><li><p>偏移图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165225.png" alt="image-20230906211056672" style="zoom:80%;"></li></ul><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><ul><li><p>原因：平移为非线性变换 不方便<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165228.png" alt="image-20230906211326174"></p></li><li><p>方法：（二维坐标）将点(x, y)记为(x, y, 1), 将向量(x, y)记为(x, y, 0)</p></li><li><p>好处：</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165231.png" alt="image-20230906211516803"></p><p>  注：点 + 点 可得两点间中点</p><p>  即可将平移记为</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165234.png" alt="image-20230906211636249" style="zoom: 50%;"></li><li><p>注意：矩阵乘积顺序对结果有影响 齐次坐标前同一矩阵先运用线性变换在运用平移操作</p></li><li><p>思考：如何不绕原点旋转？</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165237.png" alt="image-20230906212021706"></p></li></ul><p>三维同理(x, y, z, 0), (x, y, z ,1)</p><hr><h3 id="观测变换（三维"><a href="#观测变换（三维" class="headerlink" title="观测变换（三维"></a>观测变换（三维</h3><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>绕谁谁不变</p><ul><li>循环对称性质</li></ul><p>$$<br>  绕x与z时，\vec{y}\times\vec{z} = \vec{x}，\vec{x}\times\vec{y} = \vec{z}，属于同一方向旋转（记为逆时针旋转<br>$$</p><p>$$<br>  而绕y旋转时，\overrightarrow{x}\times\overrightarrow{z} = -\overrightarrow{y}，故须旋转-\alpha<br>$$</p><p>* </p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165243.png" alt="image-20230907175453358" style="zoom:33%;"><ul><li>罗德里格斯旋转公式（复杂旋转转为xyz旋转<br>$$<br>绕旋转轴\overrightarrow{n}旋转\alpha度<br>$$<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165243.png" alt="image-20230907181022234" style="zoom: 33%;"></li></ul><h4 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h4><ul><li><p>三步变换（mvp变换</p><ol><li>模型变换：搭建场景</li><li>视图变换：找好相机角度</li><li>投影变换：将三维空间投影到二维平面</li></ol></li><li><p>相机</p><ul><li>放在哪（e）</li><li>往哪看（g）</li><li>向上方向（t）</li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165255.png" alt="image-20230907182706869" style="zoom: 33%;"><p>因为 相对移动</p><p>可假设相机一直在原点，朝向-z方向，y向上</p><p>//好处：扔掉z轴，呈现图像就是关于xy的平面图</p><ul><li><p>如何操作？</p><ol><li><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165259.png" alt="image-20230907183104377" style="zoom:33%;"></li><li><p>将<strong>g</strong>旋转到-<strong>z</strong>，<strong>t</strong>旋转到<strong>y</strong>，（<strong>g</strong> x <strong>t</strong>）旋转到<strong>x</strong> （难求）</p></li><li><p>故先将将-<strong>z</strong>旋转到<strong>g</strong>，<strong>y</strong>旋转到<strong>t</strong>，<strong>x</strong>旋转到（<strong>g</strong> x <strong>t</strong>），所需变换即该结果的逆</p></li><li><p>由于旋转矩阵为正交矩阵，矩阵的逆等于转置</p><p>故得<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165303.png" alt="image-20230907183902497" style="zoom:33%;"></p></li></ol></li></ul></li></ul><h4 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h4><ul><li><p>正交投影</p><ul><li><p>简单思路：将相机如上摆放后，使所有物体z=0，再将所有物体移到x、y均在-1到1的小方片上 即可将物体投影到xy平面，即正交投影的结果</p></li><li><p>正式做法：</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165308.png" alt="image-20230910194622039"></p><p>把任何形状变成标准立方体</p><ol><li>平移：把中心移到原点</li><li>缩放：把x、y、z宽度缩放为2（对应-1到1</li></ol><p>对应矩阵：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165312.png" alt="image-20230910195031304" style="zoom: 33%;"></li></ul></li><li><p>透视投影</p><ul><li><p>引子：齐次坐标性质</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165318.png" alt="image-20230911170159196"></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165353.png" alt="image-20230911170607698" style="zoom:33%;"></li><li><p>思路：</p><ol><li><p>将远平面挤到近平面相同大小</p><p>挤压过程中：</p><ul><li>近平面四个顶点不发生变化</li><li>原平面z轴不发生变化</li><li>远平面中心点不发生变化</li></ul></li><li><p>用正交投影方法将远平面投影到近平面上</p></li></ol><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170144.png" alt="image-20230911171317815"></p><p>需要将矩阵化为</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165408.png" alt="image-20230911191530990" style="zoom:33%;"><p>即左乘矩阵<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165414.png" alt="image-20230911191827177" style="zoom:33%;"></p><ol><li><p>对于给定的深度n（在近平面上）：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165420.png" alt="image-20230911192059835" style="zoom:33%;"><p>故可得用待定系数法求第三行（与x、y无关，故前两项为0</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165427.png" alt="image-20230911192148729" style="zoom: 33%;"></li><li><p>对于远平面中心点：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165432.png" alt="image-20230911193102032" style="zoom:33%;"></li></ol><p>由1、2可得：<br>$$<br>\begin{cases}<br>\begin{aligned}<br>An + B = n^2\<br>Af +B=f^2<br>\end{aligned}<br>\end{cases}<br>\Rightarrow<br>\begin{cases}<br>\begin{aligned}<br>A=n+f\<br>B=-nf<br>\end{aligned}<br>\end{cases}<br>$$<br><strong>自此第一步把远平面挤压至近平面大小完成</strong></p><p>最终转化矩阵即此结果所求矩阵右乘正交转化矩阵</p></li><li><p>其他：经此变换后近平面、远平面的点z值不变，但中间的点z值并非不变(z变大，即变近)</p></li></ul></li></ul><hr><h3 id="光栅化成像"><a href="#光栅化成像" class="headerlink" title="光栅化成像"></a>光栅化成像</h3><h5 id="透视投影的视锥定义方式"><a href="#透视投影的视锥定义方式" class="headerlink" title="透视投影的视锥定义方式"></a>透视投影的视锥定义方式</h5><ol><li>视图宽高比</li><li>垂直可视角度（红线所成角度）（红线所连点为长宽中点）</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165437.png" alt="image-20230911204909056" style="zoom: 50%;"><p>光栅化：把东西画在屏幕上</p><p>即将[-1, 1]^2的方块映射到[0, width] * [0, height]的屏幕上</p><p>步骤：</p><ol><li><p>缩放：将[-1, 1]拉伸至需求大小</p></li><li><p>平移：由于坐标计算从左下角开始，需将中心平移至原点</p><p>合并1、2可得矩阵：<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165443.png" alt="image-20230911211622374" style="zoom:33%;"></p></li><li><p>光栅化：将图形打成像素</p></li></ol><p>三角形：最基础的多边形</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><ul><li><p>概念：把函数离散化的过程</p></li><li><p>应用：设立函数，当中心在三角形内部时返回1，否则返回0</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165448.png" alt="image-20230912163111534" style="zoom:50%;"></li><li><p>具体实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> ymax<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>        image<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">inside</span><span class="token punctuation">(</span>tri<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包围盒：找到顶点x、y的最小与最大值，形成包围盒 只用对其内的像素做光栅化处理</p></li></ul><h5 id="锯齿"><a href="#锯齿" class="headerlink" title="锯齿"></a>锯齿</h5><ul><li>原因：<ol><li>像素本身大小</li><li>采样率不够高</li></ol></li><li>抗锯齿/反走样</li></ul><h5 id="抗锯齿-反走样"><a href="#抗锯齿-反走样" class="headerlink" title="抗锯齿/反走样"></a>抗锯齿/反走样</h5><ul><li><p>现象（artifact）</p><ul><li>锯齿</li><li>摩尔纹</li><li>车轮效应（时间上的采样</li></ul></li><li><p>原因：信号速度太快 采样速度跟不上</p></li><li><p>反走样方法：在采样之前进行滤波/模糊</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165455.png" alt="image-20230912194812624" style="zoom:50%;"></li><li><p>why？</p></li></ul><p>$$<br>  定义\cos2\pi fx， f即频率<br>$$</p><ul><li><p>前言：<strong>傅里叶级数展开</strong></p><p>任何一个周期函数可以写成一系列正弦余弦的线性组合加常数的形式</p></li><li><p>引出：<strong>傅里叶变换</strong></p><ul><li><p>定义：给定任意一个函数可以经过一系列变换操作变为另一函数 通过逆变换可以变回原函数</p></li><li><p>作用：把一个函数从时域变到频域</p></li><li><p>例子：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165501.png" alt="image-20230912201416900" style="zoom:50%;"><p>右图为变换后图片 中间为低频 四周为高频 亮度表明图片信息主要集中于低频</p></li></ul></li><li><p>即 走样：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165507.png" alt="image-20230912200155332" style="zoom:50%;"></li></ul><h6 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h6><ul><li><p>意思：把某特定频段删去</p></li><li><p>例子（高通滤波）：用滤波将刚刚的图的低频信号滤去再逆变换为原图得到左图</p><p>可得高频主要为图像剧烈变换部分</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165516.png" alt="image-20230912201740247" style="zoom:50%;"></li><li><p>低通滤波：与上相反 边界模糊了</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165522.png" alt="image-20230912202128305" style="zoom:50%;"></li></ul><h6 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h6><ul><li><p>概念过程：下面三格窗口向右移动 与对应三数相乘后填回格子中</p><p>即对每三个各自做加权平均</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165530.png" alt="image-20230912202528804"></p></li><li><p>卷积定理：<strong>时域上的卷积等于频域上的乘积，频域上的卷积也等于时域上的乘积</strong>（卷积的对偶性）(互逆)</p><p>例：此例中任何一个像素等于周围像素平均 故得模糊图 频域上类似低通滤波</p><p>乘1/9使图像整体颜色(亮度)值经过卷积操作后不发生变化（求均值）</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165535.png" alt="image-20230912202928413"></p><p>卷积区域越大<code>(9*9 -&gt; 63*63)</code> 得到的图像越模糊 频域上白色越小、越接近中心</p></li></ul><h6 id="采样在频域上的意义"><a href="#采样在频域上的意义" class="headerlink" title="采样在频域上的意义"></a>采样在频域上的意义</h6><ul><li><p>冲激函数</p><p>只在特定位置上有值，其他位置上无值的函数（函数c）</p></li><li><p>采样即可表示为一个函数乘以一系列冲激函数后的结果</p><p>即 <code>a * c = e</code></p></li><li><p>对应的频域操作</p><p>即在频域上对对应的函数进行卷积操作 <code>b 卷积 d = f</code></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165542.png" alt="image-20230918165042506" style="zoom:33%;"></li><li><p>即采样为<strong>频谱的重复</strong></p><p>得出产生走样现象的原因是采样频率不够快导致复制时采样的频谱出现了混叠</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165547.png" alt="image-20230918165449087" style="zoom:50%;"></li></ul><h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><ol><li><p>增加采样率</p><p>受制于物理限制</p></li><li><p>反走样</p><p><strong>先做模糊 再做采样</strong></p><p>即先进行低通滤波(去除高频) 再进行采样</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165552.png" alt="image-20230918170026947" style="zoom:50%;"><ul><li><p>例子</p><p>用大小为一个像素的低通滤波器对三角形进行卷积操作(取平均)</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165558.png" alt="image-20230918170720729" style="zoom:50%;"></li><li><p>怎么算？？(1)</p><p><strong>MSAA</strong>(对反走样的近似)</p><p>依靠<strong>模糊</strong>解决走样问题 <strong>并没有提高分辨率</strong></p><p>将一个像素拆分为几个较小像素(增加采样点) 取每个像素内采样点在三角形内的平均覆盖率 用此值乘以三角形原本颜色</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165603.png" alt="image-20230918171248715" style="zoom:25%;"><p>=&gt;</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165609.png" alt="image-20230918171309781" style="zoom:25%;"><p>由于采样频率为一个像素，此模糊操作结束后所得图形即反走样图形</p><p>代价：增大计算量</p></li><li><p>FXAA(Fast Approximate AA)</p><ol><li>得到一副有锯齿的图片</li><li>找到锯齿边界</li><li>替换为无锯齿边界</li></ol></li><li><p>TAA(Temporal AA)</p><p>复用上一帧的结果</p><p>相当于把MSAA对应的样本分布在时间上</p></li></ul></li></ol><h5 id="超分辨率"><a href="#超分辨率" class="headerlink" title="超分辨率"></a>超分辨率</h5><p>无锯齿放大图片分辨率</p><ul><li><p>DLSS(深度学习)</p><p>将细节猜出来</p></li></ul><p>与抗锯齿不同 但本质相同</p><h5 id="遮挡-深度"><a href="#遮挡-深度" class="headerlink" title="遮挡(深度)"></a>遮挡(深度)</h5><ul><li><p>画家算法<code>O(nlogn)</code></p><p>先画远的 再画近的</p><p>弊端：无法定义互相遮挡的深度关系</p></li><li><p>深度缓存 Z-Buffer<code>O(n)</code></p><p>生成结果图(frame buffer)的同时生成场景中任何一个像素的深度(depth(z) buffer)</p><p>注：始终假设相机看向-z 与这里的深度相反</p><p>一开始每个像素深度设为无限远 之后一步步记录到最小深度</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165614.png" alt="image-20230918195842260" style="zoom:50%;"><p>好处：结果与渲染顺序无关(由于浮点型判断相等十分困难 可假设没有两个图形位于同一深度的情况)</p></li></ul><hr><h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><ul><li>定义：对不同物体运用不同材质的过程</li><li>注：着色不包括阴影</li></ul><h4 id="基础着色模型-Blinn-Phong反射模型"><a href="#基础着色模型-Blinn-Phong反射模型" class="headerlink" title="基础着色模型(Blinn-Phong反射模型)"></a>基础着色模型(<code>Blinn-Phong反射模型</code>)</h4><p>物体表面颜色可分为</p><ol><li>物体高光</li><li>漫反射部分</li><li>间接光照</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165627.png" alt="image-20230918202924853" style="zoom:50%;"><h5 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h5><p>假设物体一截取小段平面必为平面 定义 v为观测方向 l为光照方向 n为法线(<strong>均为单位向量</strong>) 及物体表面属性</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165634.png" alt="image-20230918203210649" style="zoom:50%;"><p>单位面积接收到的能量(光)与${\cos\theta = \vec l \cdot \vec n}$成正比</p><p>对于点光源的周围，假设光波传播过程中不消耗能量，则光传播越远光球壳表面积越大，单位面积能量就越小。设单位面积能量为<code>I</code>，则：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165643.png" alt="image-20230921002535608" style="zoom:50%;"><p>单位面积接收到的能量(光)与$r^2$成反比</p><p>即：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165650.png" alt="image-20230921003130086" style="zoom: 33%;"><p>注：$\vec n \cdot \vec l &lt; 0$时表示从面的一边射到面的另一边，在这里没有实际意义，故取0</p><p>系数<code>kd</code>为对漫反射颜色的吸收，可表示成[0, 1]的<code>rgb</code>的向量</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165657.png" alt="image-20230921004444372" style="zoom:33%;"><p>注2：漫反射能量与观测角度无关</p><h5 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h5><p>光滑的物体表面光的方向接近镜面反射，故只有观测角度与高光角度接近时才能看到高光</p><p>由于反射向量难以计算 可转化为法线向量与<code>半程向量</code>接近(点乘接近1)</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165702.png" alt="image-20230921005815645" style="zoom:50%;"><ol><li><p>高光一般为白色，故镜面反射系数<code>ks</code>一般为白色。</p></li><li><p>被吸收的能量(n 点乘 l)被简化</p></li><li><p>指数p可以提高容忍度(一般为100 到 200)</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165708.png" alt="image-20230921010427632" style="zoom:33%;"></li><li><p>例子：漫反射与高光结合后的图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165713.png" alt="image-20230921010522222" style="zoom:50%;"></li></ol><h5 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h5><p>由于环境光照过于复杂，假设任何一个点接触到的环境光照永远相同。实际为一个常数。</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165718.png" alt="image-20230921010833759" style="zoom:33%;"><p>对所有的点进行此着色模型可得：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165722.png" alt="image-20230921011005078" style="zoom:50%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165727.png" alt="image-20230921011048843" style="zoom:50%;"><h4 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h4><p>将着色运用在哪些点上</p><ul><li><p>Flat Shading<br>对三角形两边做叉积得到法线，并在每个三角形内部进行统一着色</p></li><li><p><code>Gouraud Shading</code><br>对平面的每个顶点周围三角形的法线求平均，进行着色，并在中间进行插值</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165732.png" alt="image-20230921012630037" style="zoom:25%;"></li><li><p><code>Phong Shading</code><br>求出顶点法线 在三角形内部对法线方向进行插值，得到任意一点的法线方向，对每个像素点进行着色</p></li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165737.png" alt="image-20230921012232928" style="zoom:50%;"><hr><h3 id="实时渲染管线"><a href="#实时渲染管线" class="headerlink" title="实时渲染管线"></a>实时渲染管线</h3><p>从三维场景到二维图的过程</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165742.png" alt="image-20230921183047880" style="zoom:50%;"><ol><li>输入顶点</li><li>生成三角形</li><li>光栅化</li><li>着色</li><li>纹理映射</li><li>输出</li></ol><p><code>Shader</code>即内置管线处理过程中可自定义修改部分。会自动应用在每个顶点或每个像素(片元)上</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165748.png" alt="image-20230921184458360" style="zoom:50%;"><p>其中用到简单的<code>Phong</code>模型光线计算</p><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>定义在着色过程中不同位置的不同物体属性(如漫反射系数)实现纹理</p><p>三维物体表面的纹理其实是二维的，物体表面上的点与二维图像上点的映射即纹理映射</p><h4 id="uv坐标"><a href="#uv坐标" class="headerlink" title="uv坐标"></a><code>uv坐标</code></h4><p>假设映射关系已知，设纹理图为在<code>uv坐标</code>上的一张图(u、v均在[0, 1])</p><p>tileable texture：将纹理复制连接在上下左右后依然连续</p><h4 id="重心坐标-插值"><a href="#重心坐标-插值" class="headerlink" title="重心坐标(插值)"></a>重心坐标(插值)</h4><ul><li>作用：做插值，在平面内进行平滑过渡</li><li>插值什么：颜色、法线…</li></ul><p>将三角形上任意一点表示为A B C坐标的线形组合，则重心为系数相加为1的点</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165753.png" alt="image-20230921194024695" style="zoom:50%;">即$\begin{cases} (x, y) = \alpha A+ \beta B + \gamma C\\alpha + \beta + \gamma = 1 \end{cases}$ , 可用$(\alpha, \beta, \gamma)$ 表示点(x, y)</p><p>仅当$\alpha、\beta、\gamma$均非负时，中心才在三角形内 如不满足$\alpha + \beta + \gamma = 1$则该点不在三角形的平面内</p><ol><li>由奔驰定理可求得每点的重心坐标 <img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165759.png" alt="image-20230921200550116" style="zoom:50%;"></li><li><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165804.png" alt="image-20230921200948917" style="zoom:50%;"></li></ol><p>而三角形重心的重心坐标即 $(\frac13, \frac13, \frac13)$</p><p>注：转换为投影坐标后<strong>不能</strong>保证重心坐标不变，故三维坐标下应<strong>先算出重心坐标</strong>，做完插值再进行投影操作</p><h4 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h4><h5 id="纹理太小"><a href="#纹理太小" class="headerlink" title="纹理太小"></a>纹理太小</h5><ul><li><p>简单方法：对每个像素点，计算出<code>uv</code>坐标，将对应的纹理设为该像素点的漫反射系数</p></li><li><p>问题：纹理太小无法完全覆盖所有像素点？（高分辨率下，<code>uv</code>坐标可能对应小数）</p></li><li><p>解决：坐标四舍五入，使多个像素点映射到同一个纹理点上，导致低分辨率</p></li><li><p>进一步解决：<strong>双线性插值</strong>（点查询）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165810.png" alt="image-20230926171320165" style="zoom:33%;"><p>取小数<code>uv</code>坐标周围四个点，进行水平方向和竖直方向上的插值，即可得到任意点的平滑过渡</p></li><li><p><strong>双三次插值</strong>/<strong>双立法插值</strong></p><p>取周围临近16个点做三次插值</p></li><li><p>结果对比</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165818.png" alt="image-20230926171836809" style="zoom:50%;"></li></ul><h5 id="纹理太大"><a href="#纹理太大" class="headerlink" title="纹理太大"></a>纹理太大</h5><ul><li><p>现象：严重的摩尔纹与锯齿（走样）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165824.png" alt="image-20230926180808796" style="zoom: 33%;"></li><li><p>原因：一个像素覆盖的纹理上的区域太大</p></li><li><p>解决方法：之前学过的<strong>超采样</strong> 可以解决，但消耗巨大</p></li></ul><h6 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h6><ul><li><p>方法2：不进行采样 即<strong>mipmap</strong>（图像金字塔）（范围查询）</p><p>快、近似、正方形</p><p>一共$\log_2n$层 存储量只多了$\frac13$</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165830.png" alt="image-20230927154435559" style="zoom:50%;"><p>近似方法：四周在<code>uv</code>坐标下距离差距的最大值L <code>L*L</code>即一个像素在<code>uv</code>坐标下的覆盖范围 这个正方形在Mipmap中第D层一定能取到<code>1*1</code>的大小</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165838.png" alt="image-20230927161329940" style="zoom:50%;"><p>结果：<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165843.png" alt="image-20230927162611719" style="zoom:50%;"></p><p>问题：会有分层不连续的结果</p><p>解决：<strong>三线性插值</strong>在上下两层分别进行双线性插值，再对两层的结果分别进行插值</p><p>结果:</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165849.png" alt="image-20230927163039095" style="zoom: 50%;"></li></ul><h6 id="各向异性过滤"><a href="#各向异性过滤" class="headerlink" title="各向异性过滤"></a>各向异性过滤</h6><ul><li><p>STILL问题：过分模糊<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165857.png" alt="image-20230927163314457" style="zoom:50%;"></p></li><li><p>原因：1. 近似 2. 只能查询正方形，在计算长条形区域时加入了不必要的平均</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165902.png" alt="image-20230927163932352" style="zoom:50%;"></li><li><p>解决：各向异性过滤（<code>ripmap</code>）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165908.png" alt="image-20230927163621568" style="zoom:33%;"><p>对于这张图，<code>mipmap</code>只实现对角线上图片，而这张图可以将查询范围从正方形扩大到矩形</p><p>内存变为原来的三倍</p><p>基本只影响显存开销，不增加计算量</p></li><li><p>still：对于斜向区域无法很好的近似</p></li><li><p><strong>EWA过滤</strong></p><p>基本思路：把一个不规则形状拆成很多圆形，多次查询覆盖原形状</p><p>问题：时耗大</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑器简单拓展</title>
      <link href="/posts/bian-ji-qi-jian-dan-tuo-zhan/"/>
      <url>/posts/bian-ji-qi-jian-dan-tuo-zhan/</url>
      
        <content type="html"><![CDATA[<h3 id="编辑器简单拓展"><a href="#编辑器简单拓展" class="headerlink" title="编辑器简单拓展"></a>编辑器简单拓展</h3><p>!!!<code>UnityEditor</code>不能被游戏内脚本引用 否则会导致打包失败</p><p><code>[HideInInspector]</code> 隐藏公共成员变量 防止inspector的值影响它</p><p><code>[SerializeField]</code> 使私有变量在检视面板可见[^1]</p><p><code>[Serializable]</code> 使<strong>对象</strong>可序列化</p><p><code>[Range(a, b)]</code> 使变量显示时显示a-b的滑动条范围</p><p><code>[Tooltip]</code> 在编辑器显示时的悬浮提示文字</p><p>*一个成员变量可添加多个特性</p><p><code>[Header("分类")]</code> 在上方显示小类名</p><p><code>[Space(50)]</code> 隔开50像素距离</p><p><code>[Multiline(5)]</code> 指定文字输入框为五行</p><p><code>[TextArea(5, 10)]</code> 使文本框在最小范围(5)到最大范围(10)之间自动变换 如多于最大行则以滚动条形式显示</p><p><code>[ContextMenu("函数作用")]</code> 使小齿轮处增加一个回调函数</p><p><code>[ContextMenuItem("悬浮显示提示", "回调函数名")]</code> 给成员变量添加右键菜单回调函数</p><p><code>[RequireComponent(typeof(组件名)]</code> 组件依赖 自动添加依赖的组件 且当改组件未被移除时依赖组件不允许删除</p><p><code>[ExecuteInEditMode]</code> 使生命周期函数在编辑器状态下可以执行(不影响游戏中正常使用) *Update在场景中对象发生变化或项目组织发生变化时会执行</p><p>[^1]: Unity会将对象进行序列化存储, 故私有变量标记为可序列化对象后可显示.公有变量默认可序列化.</p><hr><h3 id="编辑器深度拓展"><a href="#编辑器深度拓展" class="headerlink" title="编辑器深度拓展"></a>编辑器深度拓展</h3><p><code>[addComponentMenu("目录名/脚本名", 1)]</code> 将组建添加到<code>AddComponent</code>上, 目录名可省略 1为在列表中显示顺序 脚本名不用与类名相同</p><h4 id="检视器高级编程-外挂式编程"><a href="#检视器高级编程-外挂式编程" class="headerlink" title="检视器高级编程(外挂式编程)"></a>检视器高级编程(外挂式编程)</h4><p>在脚本外挂脚本从而修改脚本</p><ol><li>在项目中建立Editor目录</li><li>在目录中建立脚本控制脚本</li><li>将两个脚本关联<ol><li>引入<code>UnityEditor</code>命名空间</li><li>让Editor脚本继承Editor类</li><li><code>[CustomEditor(typeof("控制的类名"))]</code> 建立关联关系</li><li>创建成员变量 在<code>OnEnable()</code>函数中获得需要编辑显示组件</li></ol></li></ol><pre class="line-numbers language-c#"><code class="language-c#">private Player _Component;//当关联组件所在对象被选中或组件被添加时调用void OnEnable(){    _Component = target as Player;}//当关联组件所在对象被取消选中或组件被移除时调用void OnDisable(){    _Component = null;} //用于绘制检视面板的生命周期函数(每帧绘制编辑器时被调用)public override void OnInspectorGUI(){    //标题显示    EditorGUILayout.LabelField("标题名");    //赋值使在编辑器中对变量值的修改生效    _Component.ID = EditorGUILayout.IntField("显示名", _Component.ID);    //其他值类型同理 除布尔类型为EditorGUILayout.Toggle    //对象数据类型:显示名 值 类型 是否可以拖入赋值    _Component.Weapon = EditoeGUILayout.ObejectField("", _Component.Weapon, typeof("GameObject"), true) as GameObject;    //单选枚举    _Component.Pro = (枚举名)EditorGUILayout.EnumPopup("显示名", 值);    //多选枚举    _Component.Color = (枚举名)EditorGUILayout.EnumFlagsField("显示名", 值);    //终极数据类型绘制(支持任何数据类型)    //更新可序列化数据    serializedObject.Update();    //通过成员变量名找到组件上的成员变量    SerializedProperty sp = serializedObject.FindProperty("Items");    //可序列化数据绘制(取到的数据, 标题, 是否显示所有获得的序列化数据)    EditorGUILayout.PropertyField(sp, new GUIContent("道具信息"), true);    //将修改的数据写入可序列化的原始数据中    serializedObject.ApplyModifiedProperties();    //滑动条绘制(标题 值 最小值 最大值)    _Component.Atk = EditorGUILayout.Slider(new GUICoontent("玩家攻击力"), _Component.Atk, 0, 100);        if(_Component.Atk > 80){        //显示红消息框        EditorGUILayout.HelpBox("攻击力太高了", MessageType.Error);    }    if(_Component.Atk < 20){        //显示黄消息框        EditorGUILayout.HelpBox("攻击力太低了", MessageType.Warning);    }        //绘制按钮(默认纵向排列)    GUILayout.Button("按钮名");    //横向绘制    EditorGUILayout.BeginHorizontal();    if(GUILayout.Button("检查")){        Debug.Log("检查");    }    if(GUILayout.Button("排查")){        Debug.Log("排查");    }    EditorGUILayout.EndHorizontal();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h4><pre class="line-numbers language-c#"><code class="language-c#">using UnityEditor;public class PopWindow : EditorWindow{    //使顶部菜单出现方法    [MenuItem("工具/创建窗口")]    static void OpenWindow(){        //泛型内类型表示用哪个脚本创建窗口(是否为工具窗口 标题 是否打开立刻获得焦点)        GetWindow<PopWindow>(false, "弹窗标题", true);        window.minSize = new Vector(400, 300);        window.maxSize = new Vector(800, 600);    }    //打开窗口时调用    private void OnEnable(){            }    //关闭窗口时调用    private void OnDisable(){            }    //窗口处于开启状态时调用    private void Update(){            }    private void OnGUI(){        //在此可用上面OnInspectorGUI中函数绘制界面       }    //当场景发生变化时执行    private void OnHierarchyChange(){            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Study </tag>
            
            <tag> Unity Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恋上算法与数据结构笔记</title>
      <link href="/posts/lian-shang-suan-fa-yu-shu-ju-jie-gou-bi-ji/"/>
      <url>/posts/lian-shang-suan-fa-yu-shu-ju-jie-gou-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        value <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>思路:链表只能获取每个节点的值和它的下一个节点 删除节点(对外)只需要删除这个数据</p><ol><li><p>将要删除的节点的下一个节点的数据覆盖到该节点</p></li><li><p>让该节点指向下一个节点的下一个节点</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token punctuation">.</span>value <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ol><li><p>每次用<code>reverseList(head.next)</code>获取从下一个节点开始反转之后的链表</p></li><li><p>让head的下一个节点指向head</p></li><li><p>让head指向空</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//空链表或只有一个节点</span>        ListNode newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从head.next开始反转，得到的newHead相当于图片中红框部分。</span>    head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//head.next为4，将4的next指向5</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使5的next指向null</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><ol><li>创建一个新空链表<code>newHead</code></li><li>让head节点指向<code>newHead</code></li><li>让<code>newHead</code>指向head节点</li><li>让head指向下一个节点</li><li>循环直到head指向空</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList2</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode newHead <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode temp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>        newHead <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="环形链表-快慢指针"><a href="#环形链表-快慢指针" class="headerlink" title="环形链表-快慢指针"></a>环形链表-快慢指针</h3><ol><li>定义两个指针 一个跑得快 一个跑得慢</li><li>如果有环形链表 快指针和慢指针一定会有时刻重合(快的一定会追上慢的)</li><li>如果不是环形链表 快的一定会先指向null</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>元素必大于左子树上的任何元素, 小于右子树上的任何元素</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>    E element<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//父节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右子节点</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><ol><li>找到父节点</li><li>创建新节点</li><li>将节点插入空位</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E element<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//添加的节点为根节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//添加的节点不是根节点</span>    <span class="token comment" spellcheck="true">//找到父节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> parent <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存最后一个找到的节点</span>    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存最后一次比较的结果</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        cmp <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> node<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//相等</span>            <span class="token comment" spellcheck="true">//不允许相等：两种方法 1.忽略(chosen) 2.覆盖</span>            <span class="token comment" spellcheck="true">//允许相等：合并入上面的一种情况</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入方向</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h4><ol><li>删除节点为叶子节点：直接删除</li><li>度为1的节点：用子节点替代原节点位置</li><li>度为2的节点：用此节点的前驱节点或后继节点代替此节点</li></ol><p>注：如果一个节点的度为2，那么它的前驱、后继节点的度只可能是0或1</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//度为2</span>        <span class="token comment" spellcheck="true">//找到前驱节点</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">preccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//用前驱节点的值覆盖度为2的节点的值</span>        node<span class="token punctuation">.</span>element <span class="token operator">=</span> p<span class="token punctuation">.</span>element<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除前驱节点</span>        node <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//删除node</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> replacement <span class="token operator">=</span> node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">?</span> node<span class="token punctuation">.</span>left <span class="token operator">:</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>replacement <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//node是度为1的节点</span>        <span class="token comment" spellcheck="true">//更改parent</span>        replacement<span class="token punctuation">.</span>parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//更改parent的left\right指向</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            root <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//node是叶子节点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            root <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="前序遍历-Preorder-Traversal"><a href="#前序遍历-Preorder-Traversal" class="headerlink" title="前序遍历(Preorder Traversal)"></a>前序遍历(<code>Preorder Traversal</code>)</h4><p>访问顺序: 根节点, 前序遍历左子树, 前序遍历右子树(类似<code>dfs</code>)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//访问操作</span>    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历-Inorder-Traversal"><a href="#中序遍历-Inorder-Traversal" class="headerlink" title="中序遍历(Inorder Traversal)"></a>中序遍历(<code>Inorder Traversal</code>)</h4><p>访问顺序: 中序遍历左子树, 根节点, 中序遍历右子树(或左右互换)</p><p>特性: 访问后数据为升序(如先访问右子树则为降序)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//访问操作</span>    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序遍历-Postorder-Traversal"><a href="#后序遍历-Postorder-Traversal" class="headerlink" title="后序遍历(Postorder Traversal)"></a>后序遍历(<code>Postorder Traversal</code>)</h4><p>访问顺序: 后序遍历左子树, 后序遍历右子树, 根节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//访问操作</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="层序遍历-Lever-Order-Traversal"><a href="#层序遍历-Lever-Order-Traversal" class="headerlink" title="层序遍历(Lever Order Traversal)"></a>层序遍历(Lever Order Traversal)</h4><p>访问顺序: 从上到下 从左到右访问(类似于<code>bfs</code>)</p><p>思路: 队列</p><ol><li>将根节点入队</li><li>循环执行:<ol><li>将队头节点a出队并访问</li><li>将a的左子节点入队</li><li>将a的右子节点入队</li></ol></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelOrderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//访问node</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">height</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//迭代(层序遍历)</span><span class="token comment" spellcheck="true">//思路: 每层最后一个访问完后队列中元素数量即下一层元素数量</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rowSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rowSize <span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rowSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            rowSize <span class="token operator">=</span> queue<span class="token punctuation">.</span>size<span class="token punctuation">;</span>            height <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断完全二叉树-利用层序遍历"><a href="#判断完全二叉树-利用层序遍历" class="headerlink" title="判断完全二叉树(利用层序遍历)"></a>判断完全二叉树(利用层序遍历)</h3><ol><li>树为空 否</li><li>左右都非空 将子节点入队</li><li>左空右非空 否</li><li>左非空右空 或 左右都空 之后节点应均为叶子节点 否则为否</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> leaf<span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>leaf <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token punctuation">.</span>isLeaf<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p>只要保证遍历到每个节点并交换均可</p><p><em>中序遍历需注意遍历完左子树交换后传入另一子树（仍为左子树）</em></p><p>eg.层序遍历（迭代）：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    TreeNode* invertTree(TreeNode* root) {        queue<TreeNode *> nodes;        nodes.push(root);        while (!nodes.empty())        {            TreeNode * node = nodes.front();            if(node != NULL){                TreeNode * temp = node->left;                node->left = node->right;                node->right = temp;                nodes.push(node->left);                nodes.push(node->right);            }            nodes.pop();        }                return root;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>eg.前序遍历（递归）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        TreeNode tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重构二叉树"><a href="#重构二叉树" class="headerlink" title="重构二叉树"></a>重构二叉树</h3><ul><li><p>前序遍历 + 中序遍历</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        if(preorder.size() == 0 || inorder.size() == 0) return NULL;        TreeNode * root = new TreeNode(preorder[0]);                int i;        for (i = 0; i < inorder.size(); i++)        {            if(inorder[i] == preorder[0]) break;        }                vector<int> leftpreorder((preorder.begin() + 1), (preorder.begin() + i + 1));        vector<int> rightpreorder((preorder.begin() + 1 + i), (preorder.end()));        vector<int> leftinorder((inorder.begin()), (inorder.begin() + i));        vector<int> rightinorder((inorder.begin() + 1 + i), (inorder.end()));        root->left = buildTree(leftpreorder, leftinorder);        root->right = buildTree(rightpreorder, rightinorder);        return root;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>后序遍历 + 中序遍历</p></li><li><p>前序遍历 + 后序遍历 + 真二叉树（节点的子节点数为0或2）</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420172637.png" alt="image-20230906195154383"></p></li></ul><h3 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h3><ul><li><p>概念：中序遍历时的前一个节点</p></li><li><p>思路：在二叉搜索树中即为前一个比它小的节点</p><p>​左子树非空时 为左子树中最大节点</p><p>​左子树空父节点非空时 向上找父节点直到node在parent右子树中</p><p>​否则 无前驱节点</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">predecessor</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//前驱节点在左子树当中(left.right.right.right...)</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> p <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//从父结点、祖父节点中寻找前驱节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//node.parent == null(没有前驱节点)</span>    <span class="token comment" spellcheck="true">//node == node.parent.right(前驱节点即父节点)</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h3><p>与前驱节点相反</p><ul><li><p>右子树非空时 为右子树中最小节点</p><p>右子树空父节点非空时 向上找父节点直到node在parent左子树中</p><p>否则无后继节点</p></li></ul><p>将上述代码中left改成right，right改成left即可</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li><p>原因：分析 二叉搜索树增 删 查复杂度均与由树高决定</p><p>如从小到大添加节点会退化成链表</p></li><li><p>平衡：节点数相同时，左右子树高度越接近树就越平衡</p></li><li><p>平衡因子：某节点左右子树高度差</p></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>每个节点的平衡因子只可能是1， 0， -1 否则为失衡</li><li>每个节点的左右子树高度差不超过1</li><li>增删改的时间复杂度为O(logn)</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>添加元素时 父节点不可能失衡 其他所有祖先节点都可能失衡</li></ul><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>原地建堆</p><p>重复执行以下步骤直到堆中元素为1</p><ol><li><p>将堆顶元素与堆底元素交换</p></li><li><p>将堆大小-1</p></li><li><p>将堆顶元素下滤</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>heapSize <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h3><p>find O(1) 找到节点父节点</p><p>union O(n) 让左边与集合内所有元素指向节点指向右边父节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> parents<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    parents<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//父节点就是根节点</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//将v1的所有元素嫁接到v2的父节点上</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> parents<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parents<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p1<span class="token punctuation">)</span><span class="token punctuation">{</span>            parents<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSame</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    retrun <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h3><p>find <code>O(logn)</code> 找到节点根节点</p><p>union <code>O(logn)</code> 让左边根节点指向右边根节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//不断向上,直到找到根节点</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        v <span class="token operator">=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//将v1的根节点嫁接到v2的根节点上</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="基于Quick-Union优化"><a href="#基于Quick-Union优化" class="headerlink" title="基于Quick Union优化"></a>基于Quick Union优化</h4><p>可能出现树不平衡,退化至链表,使find=O(n)</p><h5 id="基于size的优化"><a href="#基于size的优化" class="headerlink" title="基于size的优化"></a>基于size的优化</h5><p> 元素少的嫁接到元素多的</p><pre class="line-numbers language-java"><code class="language-java">sizes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sizes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sizes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sizes<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sizes<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>        sizes<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">+=</span> sizes<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> p1<span class="token punctuation">;</span>        sizes<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">+=</span> sizes<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a>基于rank的优化</h5><p>矮的树嫁接到高的树</p><pre class="line-numbers language-java"><code class="language-java">ranks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sizes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ranks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ranks<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ranks<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ranks<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">></span> ranks<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> p1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>        ranks<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="路径压缩-基于Quick-Union-rank优化"><a href="#路径压缩-基于Quick-Union-rank优化" class="headerlink" title="路径压缩(基于Quick Union-rank优化)"></a>路径压缩(基于Quick Union-rank优化)</h5><p>在find时使路径上所有节点指向根节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="路径分裂"><a href="#路径分裂" class="headerlink" title="路径分裂"></a>路径分裂</h5><p>使路径上的每个节点指向它的祖父节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>        parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> parents<span class="token punctuation">[</span>parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="路径减半"><a href="#路径减半" class="headerlink" title="路径减半"></a>路径减半</h5><p>是路径上每隔一个节点就指向其祖父节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> parents<span class="token punctuation">[</span>parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericUnionFind</span><span class="token operator">&lt;</span>V<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Mao<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>V<span class="token operator">>></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSet</span><span class="token punctuation">(</span>V v<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nodes<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> rerurn<span class="token punctuation">;</span>            nodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">findNode</span><span class="token punctuation">(</span>V v<span class="token punctuation">)</span><span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>V<span class="token operator">></span> node <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 (Breadth First Search)"></a>广度优先搜索 (Breadth First Search)</h4><p>以与初始节点的距离大小为顺序遍历</p><p>思路：用队列 将初始节点加入队列 之后每取出一个节点就将此节点的子节点放入队列 已加入过的节点忽略</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> beginVertex<span class="token punctuation">)</span><span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> visitedVertices <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>visitedVertices<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 (Depth First Search)"></a>深度优先搜索 (Depth First Search)</h4><p>每次走到最大距离 然后往回退走下一条路的最大距离</p><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><p>思路：递归，每次遍历该节点的子节点（子节点又会遍历自己的子节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> visitedVertices<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历</span>    visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>vertex<span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>visitedVertices<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">,</span> visitedVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><p>思路: 利用栈 先将第一个节点加入栈中</p><ol><li>弹出顶上的节点,打印节点</li><li>选择此节点的一条边的to节点(未被加入过的)</li><li>将此节点和to节点加入栈中</li><li>重复上述操作 直到栈为空</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>V begin<span class="token punctuation">)</span><span class="token punctuation">{</span>    Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> beginVertex <span class="token operator">=</span> vertices<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>beginVertex <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> visitedVertices <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> stack <span class="token operator">-</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>visitedVertices<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//拿到一条边后就结束循环</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="AOV网-拓扑排序-topologicalSort"><a href="#AOV网-拓扑排序-topologicalSort" class="headerlink" title="AOV网-拓扑排序 (topologicalSort)"></a>AOV网-拓扑排序 (<code>topologicalSort</code>)</h3><p>作用: 使AOV网中每个活动的前去活动都排在该活动的前面</p><p>条件: 有向无环图</p><h4 id="卡恩算法"><a href="#卡恩算法" class="headerlink" title="卡恩算法"></a>卡恩算法</h4><p>思路: </p><ol><li>将所有入度为零的节点值放入结果列表</li><li>将此节点从图中去除</li><li>重复操作,直到没有入度为零的节点</li></ol><p>结果:</p><ol><li>如果结束后列表中元素与定点总数相同,说明拓扑排序完成</li><li>如果结束后列表中元素个数小于定点总数,说明存在环,无法完成拓扑排序</li></ol><p>缺点: 需将顶点从图中删除 不符合设计原则</p><p>优化: 创建入度表,每次将节点值放入结果列表时将其所有<code>outEdges</code>对应to节点的入度减一,达成删除节点同效果.</p><p>​细节优化:一开始入度就为零的节点不涉及入度修改,不用放入入度表</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>V<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArryList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果列表</span>    Queue<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//入度为零的节点</span>    Map<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span><span class="token punctuation">,</span> Integer<span class="token operator">></span> ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//入度表</span>    <span class="token comment" spellcheck="true">//初始化 将初始入度为零的放入队列</span>    vertices<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>V v<span class="token punctuation">,</span> Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">int</span> in <span class="token operator">=</span> vertex<span class="token punctuation">.</span>inEdges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            ins<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>vertex<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 放入返回结果</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> toIn <span class="token operator">=</span> ins<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>toIn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">,</span> toIn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my fist blog!!!!!!</title>
      <link href="/posts/my-first-blog/"/>
      <url>/posts/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>The first time for me to create a blog desu!!!!!!!!!!!!!!!!!!!!!!!!!!!!!w</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
