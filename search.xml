<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于OpenCVForUnity的图像美化系统</title>
      <link href="/posts/unity-tu-xiang-mei-hua-xi-tong/"/>
      <url>/posts/unity-tu-xiang-mei-hua-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="前言介绍"><a href="#前言介绍" class="headerlink" title="前言介绍"></a>前言介绍</h2><p>​这篇文章的起因是数字图像处理这门课程的作业需要做一个基于OpenCV的图像美化系统，感觉OpenCV的各种环境配置有点麻烦，之前看到朋友用过插件实现在Unity中使用OpenCV的接口，我就寻思为什么不用Unity做这个作业呢，于是找到了<code>OpenCVForUnity</code>这个插件开整。上手后发现网上关于该插件的文章较少。虽说该插件是Java版OpenCV的复制，理论上使用起来几乎没有区别，但是经实际使用还是出现了一些问题，于是我打算将我的使用经历及踩坑情况一一记录下来。</p><p>​本文使用的Unity版本为2020.3.40f1c1版，<code>OpenCVForUnity</code>插件版本为2.5.8</p><p>​<a href="https://github.com/mashimarokumo/ImageProcess">项目地址</a>（不包含插件）<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504222543.png" alt="成品展示图"></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="图片的读取与保存"><a href="#图片的读取与保存" class="headerlink" title="图片的读取与保存"></a>图片的读取与保存</h3><p>​作业要求是自选图片地址打开，而Unity本身并没有对资源管理器中操作的相关支持。查询资料后发现需要引入c#中Comdlg.dll中的方法实现打开任务管理器并获取到用户选择文件路径。故通过此方法附加上OpenCV中自带的<code>imread</code>方法读取图像，通过<code>imwrite</code>方法保存图像。在此插件中两方法都位于<code>Imgcodecs</code>类中。代码与使用效果如下：</p><p><a href="https://blog.csdn.net/yu1368072332/article/details/89413263">参考博客地址</a></p><p>(<code>不知道为什么选c#没有代码高亮 这边就选java了 ouo</code>)</p><h4 id="引入dll"><a href="#引入dll" class="headerlink" title="引入dll"></a>引入<code>dll</code></h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/// &lt;summary></span><span class="token comment" spellcheck="true">/// 调用系统的窗口,数据接收类</span><span class="token comment" spellcheck="true">/// &lt;/summary></span><span class="token punctuation">[</span><span class="token function">StructLayout</span><span class="token punctuation">(</span>LayoutKind<span class="token punctuation">.</span>Sequential<span class="token punctuation">,</span> CharSet <span class="token operator">=</span> CharSet<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OpenFileName</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> structSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr dlgOwner <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr instance <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> String filter <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> String customFilter <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> maxCustFilter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> filterIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String file <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> maxFile <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String fileTitle <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> maxFileTitle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String initialDir <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> String title <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">short</span> fileOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">short</span> fileExtension <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String defExt <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr custData <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr hook <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> String templateName <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> IntPtr reservedPtr <span class="token operator">=</span> IntPtr<span class="token punctuation">.</span>Zero<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> reservedInt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> flagsEx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WindowDll</span><span class="token punctuation">{</span>    <span class="token punctuation">[</span><span class="token function">DllImport</span><span class="token punctuation">(</span><span class="token string">"Comdlg32.dll"</span><span class="token punctuation">,</span> SetLastError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> ThrowOnUnmappableChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> CharSet <span class="token operator">=</span> CharSet<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> extern bool <span class="token function">GetOpenFileName</span><span class="token punctuation">(</span><span class="token punctuation">[</span>In<span class="token punctuation">,</span> Out<span class="token punctuation">]</span> OpenFileName ofn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token function">DllImport</span><span class="token punctuation">(</span><span class="token string">"Comdlg32.dll"</span><span class="token punctuation">,</span> SetLastError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> ThrowOnUnmappableChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> CharSet <span class="token operator">=</span> CharSet<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> extern bool <span class="token function">GetSaveFileName</span><span class="token punctuation">(</span><span class="token punctuation">[</span>In<span class="token punctuation">,</span> Out<span class="token punctuation">]</span> OpenFileName ofd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h4><p>​除了上述问题，在这部分还出了一个小插曲。由于正版插件很贵，我也只用于学习用途，我原本是在网上随便找了一个版本的插件，用<code>imread</code>读取图片时完全没有出现问题。后来由于该版本在噪声添加方面有不可解决的问题，我又找到了现在的2.5.8版本。替换后发现读取完的图片直接用<code>matToTexture2D</code>转为Texture显示后突然出现倒置现象。找了很久的问题也没有解决，最后采用了读取后手动转正的方法。在保存时也出现了类似的问题，可能和插件中实现方式有关。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Mat <span class="token function">LoadPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        OpenFileName ofn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>structSize <span class="token operator">=</span> Marshal<span class="token punctuation">.</span><span class="token function">SizeOf</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>filter <span class="token operator">=</span> <span class="token string">"图片文件(*.jpg*.png)\0*.jpg;*.png"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//显示的可选文件</span>        ofn<span class="token punctuation">.</span>file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFile <span class="token operator">=</span> ofn<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>fileTitle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFileTitle <span class="token operator">=</span> ofn<span class="token punctuation">.</span>fileTitle<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        string path <span class="token operator">=</span> Application<span class="token punctuation">.</span>streamingAssetsPath<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//默认路径</span>        path <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>initialDir <span class="token operator">=</span> path<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"Open Project"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>defExt <span class="token operator">=</span> <span class="token string">"JPG"</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//注意 以下项目不一定要全选 但是0x00000008项不要缺少</span>        ofn<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0x00080000</span> <span class="token operator">|</span> <span class="token number">0x00001000</span> <span class="token operator">|</span> <span class="token number">0x00000800</span> <span class="token operator">|</span> <span class="token number">0x00000200</span> <span class="token operator">|</span> <span class="token number">0x00000008</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OFN_EXPLORER|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST| OFN_ALLOWMULTISELECT|OFN_NOCHANGEDIR</span>        <span class="token comment" spellcheck="true">//点击Windows窗口时开始加载选中的图片</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>WindowDll<span class="token punctuation">.</span><span class="token function">GetOpenFileName</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Selected file with full path: "</span> <span class="token operator">+</span> ofn<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>            Utils<span class="token punctuation">.</span><span class="token function">setDebugMode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Mat read <span class="token operator">=</span> Imgcodecs<span class="token punctuation">.</span><span class="token function">imread</span><span class="token punctuation">(</span>Utils<span class="token punctuation">.</span><span class="token function">getFilePath</span><span class="token punctuation">(</span>ofn<span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">,</span> Imgcodecs<span class="token punctuation">.</span>IMREAD_UNCHANGED<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//得到图片，读取图片通道类型遵循原图片类型</span>            <span class="token comment" spellcheck="true">//手动反转两次</span>            Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>read<span class="token punctuation">,</span> read<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>read<span class="token punctuation">,</span> read<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将原本读取的RGB颜色类型转换成Mat存储适用的BGR颜色类型</span>            Imgproc<span class="token punctuation">.</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>read<span class="token punctuation">,</span> read<span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>COLOR_RGBA2BGRA<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> read<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SavePic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        OpenFileName ofn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>structSize <span class="token operator">=</span> Marshal<span class="token punctuation">.</span><span class="token function">SizeOf</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>filter <span class="token operator">=</span> <span class="token string">"图片文件(*.jpg*.png)\0*.jpg;*.png"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFile <span class="token operator">=</span> ofn<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>fileTitle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">string</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>maxFileTitle <span class="token operator">=</span> ofn<span class="token punctuation">.</span>fileTitle<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>        string path <span class="token operator">=</span> Application<span class="token punctuation">.</span>streamingAssetsPath<span class="token punctuation">;</span>        path <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>initialDir <span class="token operator">=</span> path<span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"Open Project"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>defExt <span class="token operator">=</span> <span class="token string">"JPG"</span><span class="token punctuation">;</span>        ofn<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0x00080000</span> <span class="token operator">|</span> <span class="token number">0x00001000</span> <span class="token operator">|</span> <span class="token number">0x00000800</span> <span class="token operator">|</span> <span class="token number">0x00000200</span> <span class="token operator">|</span> <span class="token number">0x00000008</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>WindowDll<span class="token punctuation">.</span><span class="token function">GetSaveFileName</span><span class="token punctuation">(</span>ofn<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">CancelOption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Mat toSave <span class="token operator">=</span> savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>toSave<span class="token punctuation">,</span> toSave<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//手动反转</span>            Imgproc<span class="token punctuation">.</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>toSave<span class="token punctuation">,</span> toSave<span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>COLOR_BGRA2RGBA<span class="token punctuation">)</span><span class="token punctuation">;</span>            Imgcodecs<span class="token punctuation">.</span><span class="token function">imwrite</span><span class="token punctuation">(</span>ofn<span class="token punctuation">.</span>file<span class="token punctuation">,</span> toSave<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p>打开</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504222016.png"></p><p>保存</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504222231.png"></p><h3 id="调整明亮度与对比度"><a href="#调整明亮度与对比度" class="headerlink" title="调整明亮度与对比度"></a>调整明亮度与对比度</h3><p>​亮度和对比度可以通过公式$\alpha * f(i,j) + \beta$来调整。其中$\alpha$可以代表对比度，$\beta$代表亮度。在OpenCV中既可以使用遍历像素的方法实现，也可以使用自带的<code>ConvertTo</code>方法快速调整。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AdjustBrightness</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat newMat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> value <span class="token operator">=</span> brightness<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">convertTo</span><span class="token punctuation">(</span>newMat<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> newMat<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AdjustAlpha</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat newMat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> value <span class="token operator">=</span> alpha<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">convertTo</span><span class="token punctuation">(</span>newMat<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> newMat<span class="token punctuation">;</span>        curMat<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231817.jpeg" alt="img"></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231854.jpeg" alt="img"></p><h3 id="饱和度调整"><a href="#饱和度调整" class="headerlink" title="饱和度调整"></a>饱和度调整</h3><p>算法步骤：</p><ol><li><p>计算RGB三通道的最大最小值，并进一步得到delta和value。<br>$$<br>delta = (Max - Min)/255<br>$$</p><p>$$<br>value = (Max+Min)/255<br>$$</p></li><li><p>若最大最小一致，即delta=0，则表明为灰点，不需继续操作，直接处理下个像素。</p></li><li><p>通过value算出HSL中L的值<br>$$<br>L=(Max-Min)/(2*255)<br>$$</p></li><li><p>S值为<br>$$<br>\begin{cases}<br>S=delta/value,L&lt;0.5\S=delta/(2-value),L\ge0.5<br>\end{cases}<br>$$</p></li><li><p>当percent大于等于0时，即提高色彩饱和度，那么alpha值为：<br>$$<br>\begin{cases}<br>alpha = S, percent+S\ge1\<br>alpha=1-percent,else<br>\end{cases}<br>$$<br>此时，调整后的图像RGB三通道值为：<br>$$<br>RGB=RGB+(RGB-L*255)*alpha<br>$$</p></li><li><p>若percent小于0时，即降低色彩饱和度，则alpha=percent，此时调整后的图像RGB三通道值为：<br>$$<br>RGB=L<em>255+(RGB-L</em>255)*(1-alpha)<br>$$</p></li></ol><p><a href="https://blog.csdn.net/qq_55041016/article/details/124834569">算法来源</a></p><p>​当时不知道为什么这段代码一运行程序就卡死了。后来发现是这个遍历的过程特别慢，可能算法比较复杂，在每个像素上运行计算量就很大。于是我就给它加了个协程顺便记了个时，发现它是真慢。每次运行大概要8s到12s左右。推测跟插件的效率也有关？</p><pre class="line-numbers language-java"><code class="language-java">    IEnumerator <span class="token function">Sat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat newMat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> stime <span class="token operator">=</span> Time<span class="token punctuation">.</span>time<span class="token punctuation">;</span>        <span class="token keyword">float</span> saturation <span class="token operator">=</span> sat<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>curMat<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> increment <span class="token operator">=</span> <span class="token punctuation">(</span>saturation <span class="token operator">-</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token number">200f</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> curMat<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> curMat<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// R,G,B 分别对应数组中下标的 2,1,0</span>                <span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> g <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> maxn <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> minn <span class="token operator">=</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> Mathf<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> delta<span class="token punctuation">,</span> value<span class="token punctuation">;</span>                delta <span class="token operator">=</span> <span class="token punctuation">(</span>maxn <span class="token operator">-</span> minn<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">;</span>                value <span class="token operator">=</span> <span class="token punctuation">(</span>maxn <span class="token operator">+</span> minn<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">;</span>                <span class="token keyword">float</span> new_r<span class="token punctuation">,</span> new_g<span class="token punctuation">,</span> new_b<span class="token punctuation">;</span>                <span class="token keyword">float</span> light<span class="token punctuation">,</span> sat<span class="token punctuation">,</span> alpha<span class="token punctuation">;</span>                light <span class="token operator">=</span> value <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>light <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span>                    sat <span class="token operator">=</span> delta <span class="token operator">/</span> value<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    sat <span class="token operator">=</span> delta <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">-</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>increment <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>increment <span class="token operator">+</span> sat<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>                        alpha <span class="token operator">=</span> sat<span class="token punctuation">;</span>                    <span class="token keyword">else</span>                    <span class="token punctuation">{</span>                        alpha <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> increment<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    alpha <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> alpha <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_r <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> alpha<span class="token punctuation">;</span>                    new_g <span class="token operator">=</span> g <span class="token operator">+</span> <span class="token punctuation">(</span>g <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> alpha<span class="token punctuation">;</span>                    new_b <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token punctuation">(</span>b <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> alpha<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    alpha <span class="token operator">=</span> increment<span class="token punctuation">;</span>                    new_r <span class="token operator">=</span> light <span class="token operator">*</span> <span class="token number">255</span> <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>                    new_g <span class="token operator">=</span> light <span class="token operator">*</span> <span class="token number">255</span> <span class="token operator">+</span> <span class="token punctuation">(</span>g <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>                    new_b <span class="token operator">=</span> light <span class="token operator">*</span> <span class="token number">255</span> <span class="token operator">+</span> <span class="token punctuation">(</span>b <span class="token operator">-</span> light <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                newMat<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> new_b<span class="token punctuation">,</span> new_g<span class="token punctuation">,</span> new_r<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            yield <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> newMat<span class="token punctuation">;</span>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"f"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Time<span class="token punctuation">.</span>time <span class="token operator">-</span> stime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231920.jpeg" alt="img"></p><h3 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h3><p>​先加载边框图片，然后resize到原图大小，生成边框的灰度图作为mask，然后用<code>copyTo</code>方法附加到原图上。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">MakeBorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat border <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">LoadPic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//加载边框图片</span>        Mat curMat <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Imgproc<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>border<span class="token punctuation">,</span> border<span class="token punctuation">,</span> curMat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调整边框大小适应图片</span>        Mat mask <span class="token operator">=</span> border<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Imgproc<span class="token punctuation">.</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>mask<span class="token punctuation">,</span> mask<span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>COLOR_BGRA2GRAY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//生成灰度图作为mask</span>        Imgproc<span class="token punctuation">.</span><span class="token function">threshold</span><span class="token punctuation">(</span>mask<span class="token punctuation">,</span> mask<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> Imgproc<span class="token punctuation">.</span>THRESH_BINARY<span class="token punctuation">)</span><span class="token punctuation">;</span>         border<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span>curMat<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//复制边框到原图</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> curMat<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231933.jpeg" alt="img"></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504231944.jpeg" alt="img"></p><h3 id="浮雕效果"><a href="#浮雕效果" class="headerlink" title="浮雕效果"></a>浮雕效果</h3><p>​经查阅浮雕效果的原理是每个像素的RGB值都设置为该位置的初始值减去其右下方第二的像素的差，最后统一加上128用于控制灰度，显示出类似浮雕的灰色。这样处理的思路是，将图像上的每个点与它的对角线的像素点形成差值，这样淡化相似的颜色，突出不同的颜色、边缘，从而使图像产生纵深感，产生类似于浮雕的效果。（<a href="https://blog.csdn.net/qq525003138/article/details/103449413">解释来自</a>）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">FuDiao</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat src <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> CvType<span class="token punctuation">.</span>CV_8UC1<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        Mat dst <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rowNumber <span class="token operator">=</span> dst<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> colNumber <span class="token operator">=</span> dst<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rowNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> colNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                dst<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> src<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">255</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> dst<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504232034.jpeg" alt="img"></p><h3 id="简单倒影效果"><a href="#简单倒影效果" class="headerlink" title="简单倒影效果"></a>简单倒影效果</h3><p>​采用随机将像素偏移一定位置的方法创造出类似倒影的效果，再将原图与倒影图上下拼接完成效果。代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Reflection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Mat img <span class="token operator">=</span> PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>savedMat<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Mat dstImg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        img<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>dstImg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Rect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rowNumber <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> colNumber <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rowNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> colNumber <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">int</span> deltax <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> deltay <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> deltax <span class="token operator">>=</span> colNumber<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    deltax <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> deltay <span class="token operator">>=</span> rowNumber<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    deltay <span class="token operator">=</span> UnityEngine<span class="token punctuation">.</span>Random<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                img<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> img<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> deltay<span class="token punctuation">,</span> j <span class="token operator">+</span> deltax<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> deltay<span class="token punctuation">,</span> j <span class="token operator">+</span> deltax<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> deltay<span class="token punctuation">,</span> j <span class="token operator">+</span> deltax<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">255</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        Core<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> img<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        img<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Mat</span><span class="token punctuation">(</span>dstImg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Rect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PictureLoader<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span>curMat <span class="token operator">=</span> dstImg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240504232051.jpeg" alt="img"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>​感觉大部分时间都花在查资料和api以及代码的调试上了，实际上并没有很多产出。还有很多内容由于一些无法解决的问题没有实现。希望之后能继续调试并完善这个项目。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Computer Graphics </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅2022机器学习笔记</title>
      <link href="/posts/li-hong-yi-2022-ji-qi-xue-xi-bi-ji/"/>
      <url>/posts/li-hong-yi-2022-ji-qi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习方法"><a href="#机器学习方法" class="headerlink" title="机器学习方法"></a>机器学习方法</h2><ol><li><p>预测模型</p><p>猜测预测数据与已知数据的关系($y = b + wx$)</p></li><li><p>定义Loss</p><p>传入模型作为参数，平均预算误差的绝对值作为输出(MAE)</p><p>​或误差平方的平均值(MSE)</p></li><li><p>找最佳化数值</p></li></ol><h3 id="修改模型（sigmoid）"><a href="#修改模型（sigmoid）" class="headerlink" title="修改模型（sigmoid）"></a>修改模型（sigmoid）</h3><ol><li><p>考虑w</p><p>$y = b +\displaystyle\sum_{j}w_jx$</p></li><li><p>考虑模型</p></li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170845.png" alt="image-20231111154158171" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170855.png" alt="image-20231111154613377" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170903.png" alt="image-20231111154729633" style="zoom:33%;">$$y = b + \displaystyle\sum_i c_i sigmoid(b_i + \sum_jw_{ij}x_j)$$<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170911.png" alt="image-20231111160431657" style="zoom:33%;"><img src="G:/study/others/MachineLearning/pics/机器学习/image-20231111160654332.png" alt="image-20231111160654332" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170917.png" alt="image-20231111160818625" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170923.png" alt="image-20231111161049073" style="zoom:33%;">$$y = b+ \boldsymbol c^T\sigma(\boldsymbol b+\boldsymbol w\boldsymbol x)$$<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170928.png" alt="image-20231111161822839" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170934.png" alt="image-20231111162554616" style="zoom:33%;"><p>$\eta$为自己设定的leaning rate</p><p>实际操作：B(batch size)为自己决定的参数量，将N个参数分为N/B份，每次拿一个B进行一次数值更新(update)，用光所有B为一次epoch</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170942.png" alt="image-20231111162959893" style="zoom:33%;"><h3 id="模型修改2-ReLU"><a href="#模型修改2-ReLU" class="headerlink" title="模型修改2(ReLU)"></a>模型修改2(<code>ReLU</code>)</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170948.png" alt="image-20231111163739389" style="zoom:33%;"><p>两个<code>ReLU</code>可以替换一个sigmoid，故可将原式改为$y = b+\displaystyle\sum_{2i}c_imax(0, b_i+\sum_jw_{ij}x_j)$  </p><p>这样的函数称为<strong>激活函数</strong></p><h3 id="进一步修改（增加层数）"><a href="#进一步修改（增加层数）" class="headerlink" title="进一步修改（增加层数）"></a>进一步修改（增加层数）</h3><p>对得到的数据a再进行$\sigma$操作得到$a^,$ 不断重复</p><p>问题：过拟合</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170955.png" alt="image-20231111164754541" style="zoom:33%;"><img src="G:\study\others\MachineLearning\pics\机器学习\image-20231111225724229.png" alt="image-20231111225724229"></p><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a><code>Pytorch</code></h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171002.png" alt="image-20231111225853587" style="zoom:33%;"><h3 id="生成tensor"><a href="#生成tensor" class="headerlink" title="生成tensor"></a>生成tensor</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171021.png" alt="image-20231112232309333" style="zoom:33%;"><h3 id="tensor运算操作"><a href="#tensor运算操作" class="headerlink" title="tensor运算操作"></a>tensor运算操作</h3><ul><li><p>减少长度squeeze</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171029.png" alt="image-20231112232358180" style="zoom:33%;"></li><li><p>升维<code>unsqueeze</code></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171131.png" alt="image-20231112232736627" style="zoom:33%;"></li><li><p>转置transpose</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171137.png" alt="image-20231112233001331" style="zoom:33%;"></li><li><p>组合cat</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171142.png" alt="image-20231112233202203" style="zoom:33%;"></li><li><p>其他</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171149.png" alt="image-20231112233247391" style="zoom:25%;"></li></ul><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171153.png" alt="image-20231112233517372" style="zoom:33%;"><p>可用torch.cuda.is_available() 检测是否存在可用gpu</p><h3 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h3><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171159.png" alt="image-20231112234244805" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171206.png" alt="image-20231112234503487"></p><h3 id="数据读取（data）"><a href="#数据读取（data）" class="headerlink" title="数据读取（data）"></a>数据读取（data）</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171216.png" alt="image-20231112234244805" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171222.png" alt="image-20231112234943610" style="zoom:33%;"><p>shuffle:是否乱序</p><h3 id="建立神经网络"><a href="#建立神经网络" class="headerlink" title="建立神经网络"></a>建立神经网络</h3><ul><li>线性模型</li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171230.png" alt="image-20231112235305657" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171238.png" alt="image-20231112235335026" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171244.png" alt="image-20231112235626950" style="zoom:33%;"><ul><li><p>激活函数</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171250.png" alt="image-20231112235701333" style="zoom:33%;"></li></ul><h3 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h3><p>MSE</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171256.png" alt="image-20231112235816607" style="zoom:33%;"><h3 id="产生神经网络"><a href="#产生神经网络" class="headerlink" title="产生神经网络"></a>产生神经网络</h3><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171301.png" alt="image-20231113000036718" style="zoom: 25%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171308.png" alt="image-20231113000054359" style="zoom:25%;"></p><p>sequential中依次放入不同层的函数</p><h3 id="更新模型（optimization）"><a href="#更新模型（optimization）" class="headerlink" title="更新模型（optimization）"></a>更新模型（optimization）</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171314.png" alt="image-20231113000412683" style="zoom:33%;"><p><code>lr</code>为learning rate</p><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><ul><li><p>准备</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171321.png" alt="image-20231113000607390" style="zoom:33%;"></li><li><p>一个epoch的训练</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171327.png" alt="image-20231113000756919" style="zoom:33%;"></li><li><p>模型评估</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171334.png" alt="image-20231113001259335" style="zoom:33%;"></li><li><p>测试组</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171341.png" alt="image-20231113001341676" style="zoom:33%;"></li></ul><h3 id="储存-加载模型"><a href="#储存-加载模型" class="headerlink" title="储存/加载模型"></a>储存/加载模型</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171346.png" alt="image-20231113001604544" style="zoom: 33%;"><h2 id="代码优化方法"><a href="#代码优化方法" class="headerlink" title="代码优化方法"></a>代码优化方法</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171353.png" alt="image-20231113165806187" style="zoom:33%;"><h3 id="training-loss过大"><a href="#training-loss过大" class="headerlink" title="training loss过大"></a>training loss过大</h3><h4 id="模型太过简单-重新设计模型"><a href="#模型太过简单-重新设计模型" class="headerlink" title="模型太过简单 重新设计模型"></a>模型太过简单 重新设计模型</h4><p>解决方法：</p><ul><li>加入更多features</li><li>增加neuro/layer</li></ul><h4 id="optimization不够好"><a href="#optimization不够好" class="headerlink" title="optimization不够好"></a>optimization不够好</h4><p>判断方法：比较不同模型</p><h3 id="testing-loss过大"><a href="#testing-loss过大" class="headerlink" title="testing loss过大"></a>testing loss过大</h3><h4 id="overfitting过拟合"><a href="#overfitting过拟合" class="headerlink" title="overfitting过拟合"></a>overfitting过拟合</h4><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171406.png" alt="image-20231113170659159" style="zoom:33%;"><p>解决方法：</p><ul><li><p>增加训练资料</p></li><li><p>data augmentation</p><p>用自己对资料的理解合理增加训练资料</p></li><li><p>减小模型弹性</p><ul><li>减少神经数目、共用参数</li><li>减少features</li><li>early stopping</li><li>regularization</li><li>dropout</li></ul></li></ul><h2 id="Backpropagation"><a href="#Backpropagation" class="headerlink" title="Backpropagation"></a>Backpropagation</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171412.png" alt="image-20231113205032580" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171420.png" alt="image-20231113205611772" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171430.png" alt="image-20231113205819948" style="zoom:33%;"><p>反推出偏微分</p><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>除了局部最小 gradient 为零(critical point)还可能因为处于<strong>鞍点</strong></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171438.png" alt="image-20231113172619170" style="zoom:33%;"><p>鉴别处于鞍点还是局部最小点：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171445.png" alt="image-20231113191019521" style="zoom:33%;"><p>处于critical point时g为0，故可以通过红色项判断图像趋势</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171450.png" alt="image-20231113191441848" style="zoom:33%;"><p>eigen value：特征值H为由L的二次微分组成的矩阵</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171458.png" alt="image-20231113192240520" style="zoom:33%;"><p>通过H也可求出鞍点时能让Loss变小的方向（$\theta^,\rightarrow\theta$)</p><h2 id="Batch-Momentum"><a href="#Batch-Momentum" class="headerlink" title="Batch &amp;  Momentum"></a>Batch &amp;  Momentum</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171504.png" alt="image-20231113193601124" style="zoom:33%;"><p>由于GPU平行计算，大batch效率可能会高于小batch</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171512.png" alt="image-20231113193750843" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171516.png" alt="image-20231113194701311" style="zoom:33%;"><p><strong>Momentum</strong></p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171522.png" alt="image-20231113195334045" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171529.png" alt="image-20231113195924574"></p><h2 id="自动调整学习率"><a href="#自动调整学习率" class="headerlink" title="自动调整学习率"></a>自动调整学习率</h2><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171539.png" alt="image-20231113195924574"></p><p>大体思想：在较平滑的地方lr应较大 反之则较小</p><ul><li>Adagard</li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171544.png" alt="image-20231113200528507" style="zoom:33%;"><ul><li><p>RMSProP</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171548.png" alt="image-20231113200941873" style="zoom:33%;"></li></ul><p>最常用的optimization策略：Adam（RMSProp + Momentum）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171553.png" alt="image-20231113202456036" style="zoom:33%;"><p>Learning Rate Scheduling:</p><p>由于$\sigma$随着时间累计，在g变化较小的地方步伐减小，可能出现朝着之前记录的无关方向暴增的现象，故</p><ul><li><p>Learning Rate Decay:</p><p>将$\eta$设定为随时间减小的变量</p></li><li><p>Warm Up:</p><p>使$\eta$先变大后变小</p></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>输出形式为向量，与标准做Loss前(称为logit)要先用Soft-max函数归一化（同时使大小差距更大</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171559.png" alt="image-20231113203134896" style="zoom:33%;"><p>而如果只有两种分类一般直接套用sigmoid（实质等价）（判别与生成）</p><p><strong>cross-entropy</strong></p><p>可以理解为计算两组概率之间的相似度</p><p>** 在pytorch中使用cross-entropy时自动对最后一层调用soft-max</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171603.png" alt="image-20231113203916492" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171608.png" alt="image-20231113204117032" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171614.png" alt="image-20231113212641390" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171620.png" alt="image-20231113213323356" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171625.png" alt="image-20231113213521316" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171632.png" alt="image-20231113213458428" style="zoom:33%;"><p>改进：</p><p>共用同一个$\sum$参数</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171638.png" alt="image-20231114160201310" style="zoom:33%;"><p>分界线变为直线，称这种分类模型为linear model</p><p>三步骤总结：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171642.png" alt="image-20231114160651106" style="zoom:33%;"><h2 id="逻辑回归（判别）"><a href="#逻辑回归（判别）" class="headerlink" title="逻辑回归（判别）"></a>逻辑回归（判别）</h2><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171647.png" alt="image-20231114162117186" style="zoom:33%;"><p>在共享$\sum$的前提下 经计算可将$P_{w,b}(C_1|x)$化为$f_{w,b}(x)=\sigma(wx+b)$</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171652.png" alt="image-20231114164522109" style="zoom:50%;"><p>step2中不使用square error的原因：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171658.png" alt="image-20231114164928852" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171703.png" alt="image-20231114165052873" style="zoom:33%;"><p>判别模型与生成模型找出的w与b并非同一组</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171709.png" alt="image-20231114165655869" style="zoom:33%;"><p>由于生成模型有对模型的先行猜测，一般来说判别模型优于生成模型，在少数据量的环境下生成模型也可能占优势</p><p>即判别模型受data影响大，生成模型熟data影响小</p><ul><li><p>为什么需要一个好的Training Data：</p><p>（$\sigma$为自己设定的理想差值）</p></li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171714.png" alt="image-20231115190022574" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171720.png" alt="image-20231115191455687" style="zoom:33%;"><p>故增加N（sample出来的训练资料数）或减小H（取参范围）可以减小训练资料和实际资料的差距</p><p>但是H不能太小</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171725.png" alt="image-20231115192124449" style="zoom:33%;"><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>很有趣！</p><p>专为影像识别设计的学习算法 特点：1.一个特征只要看很小部分就能知道 2.同一个特征可能出现在不同位置</p><p>先将图片缩放为统一大小，再用filter进行卷积操作</p><ol><li>经典设置</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171730.jpg" alt="img" style="zoom: 33%;"><ol start="2"><li>共享参数</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171735.jpg" alt="img" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171738.jpg" alt="img" style="zoom:33%;"><p>pooling 在横纵轴拿掉一些像素， 识别出的物体不变 降低计算量，但减少精确度</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171743.jpg" alt="img" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171747.jpg" alt="img" style="zoom:33%;"><p>为什么deep learning能减少参数量与运算速度</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171753.jpg" alt="img" style="zoom:33%;"><p>也可用于alphago（满足最开始的两个特征 去除pooling提高精确度</p><p>问题：无法处理缩放、旋转图片</p><h3 id="spatial-transformer"><a href="#spatial-transformer" class="headerlink" title="spatial transformer"></a>spatial transformer</h3><p>对原图片进行平移、旋转、缩放等操作，再投入CNN模型方便识别</p><h2 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h2><p>问题：目前输入只能是一维向量，且长度不能改变</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171759.png" alt="image-20231118162347705" style="zoom:33%;"><p>经过self-attention的向量是考虑了所有向量后生成的新向量</p><p>如何产生新向量？</p><ol><li>判断一个向量与其他各向量之间的关联性</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171804.png" alt="image-20231118162756960" style="zoom:33%;"><p>dot-product：</p><p>常用的关联性计算方式 关联性越大值越大 其中soft-max可改为任意激活方程 常用soft-max</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171809.png" alt="image-20231118164003817" style="zoom:33%;"><p>再将结果乘上矩阵得到第一个向量</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171814.png" alt="image-20231118164220097" style="zoom:33%;"><p>其中$W^v,W^q,W^q$均靠机器学习得到</p><p>写成矩阵形式：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171819.png" alt="image-20231118165442577" style="zoom:33%;"><h3 id="multi-head"><a href="#multi-head" class="headerlink" title="multi head"></a>multi head</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171824.png" alt="image-20231118192616797" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171829.png" alt="image-20231118192638718" style="zoom:33%;"><p>缺点：feature里完全未包含位置资讯</p><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171835.png" alt="image-20231118193109818" style="zoom:33%;"><p>将不同的$e^i$加到$a^i$前面 e可由特定函数求出，也可由学习得出</p><p>现有的一些positional encoding方法</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171842.png" alt="image-20231118193321083" style="zoom:33%;"><h3 id="truncated-self-attention"><a href="#truncated-self-attention" class="headerlink" title="truncated self-attention"></a>truncated self-attention</h3><p>由于有时输入向量长度过大（如语音识别等 经过self-attention时可以不看所有向量，而只看前后数个</p><h3 id="for-image"><a href="#for-image" class="headerlink" title="for image"></a>for image</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171847.png" alt="image-20231118194326843" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171903.png" alt="image-20231118194349227" style="zoom:33%;"><p>实际上，CNN为self-attention的特例</p><p>self-attention的filter范围实际通过学习决定，限制更少，弹性更大，更容易过拟合，需要的资料量更大</p><p>CNN的filter范围由人为决定，限制更多，弹性更小，小资料量下表现更好</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171908.png" alt="image-20231118195157019" style="zoom:33%;"><h3 id="对比RNN"><a href="#对比RNN" class="headerlink" title="对比RNN"></a>对比RNN</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171913.png" alt="image-20231118195616416" style="zoom:33%;"><p>RNN：</p><ol><li>只考虑当前向量之前的向量（存在双向RNN 故可忽略</li><li>新参数依赖之前计算的参数，各个参数不能平行计算。</li><li>参数关联性更难计算，最后一个参数获得第一个参数的关联需将第一个参数一直存在内存中</li><li>参数顺序有关</li></ol><h3 id="for-graph（a-kind-of-GNN）"><a href="#for-graph（a-kind-of-GNN）" class="headerlink" title="for graph（a kind of GNN）"></a>for graph（a kind of GNN）</h3><p>关联性已知，计算关联性与参数时可以指考虑相连的节点</p><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>无关：将词汇表示为vector的方法</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171918.png" alt="image-20231118200806969" style="zoom:33%;"><h3 id="Elman-Network"><a href="#Elman-Network" class="headerlink" title="Elman Network"></a>Elman Network</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171923.png" alt="image-20231118201139517" style="zoom:33%;"><p>例子：</p><p>注：三次为同一个network</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171930.png" alt="image-20231118201600461" style="zoom:33%;"><h3 id="Jordan-Network"><a href="#Jordan-Network" class="headerlink" title="Jordan Network"></a>Jordan Network</h3><p>将output存入memory，并在下个向量的hidden layer输入</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171935.png" alt="image-20231118201951393" style="zoom:33%;"><h3 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h3><p>同时train一个正向、逆向的network，将两者hidden layer参数结合考虑再投入output layer</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171940.png" alt="image-20231118202352070" style="zoom:33%;"><h3 id="Long-Short-term-Memory（LSTM）"><a href="#Long-Short-term-Memory（LSTM）" class="headerlink" title="Long Short-term Memory（LSTM）"></a>Long Short-term Memory（LSTM）</h3><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171945.png" alt="image-20231119135524436" style="zoom:33%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171952.png" alt="image-20231119135602896" style="zoom:33%;"><p>四个input中输入的都是同一参数值乘上不同的weight</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420171957.png" alt="image-20231119140623182" style="zoom:33%;"><p>故lstm network需要的参数量是普通network的四倍</p><p>矩阵形式：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420172003.png" alt="image-20231119141213464" style="zoom:33%;"><p>真正的LSTM：</p><p>（在Keras中，这个结构叫做LSTM，上面的结构为SimpleRNN， 此外，还有个GRU的简化版，只有两个门，少了1/3的参数，不容易过拟合</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420172040.png" alt="image-20231119141515123"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Games101笔记</title>
      <link href="/posts/games101-bi-ji/"/>
      <url>/posts/games101-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>向量的点乘：判断是否为同一方向</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165203.png" alt="image-20230906210147863" style="zoom:33%;"><p>点乘大于0则为同一半朝向，小于0则为反朝向</p><p>向量的叉乘：判断里外关系</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165213.png" alt="image-20230906210236659" style="zoom: 50%;"><p>各顶点出发到目标点与同点出发边向量相乘，均大于零或均小于零则为在内 否则在外</p><hr><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li><p>缩放图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165216.png" alt="image-20230906210805182" style="zoom: 80%;"></li><li><p>反转图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165219.png" alt="image-20230906210905671" style="zoom:80%;"></li><li><p>旋转图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170202.png" alt="image-20230906210657531" style="zoom:80%;"></li><li><p>偏移图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165225.png" alt="image-20230906211056672" style="zoom:80%;"></li></ul><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><ul><li><p>原因：平移为非线性变换 不方便<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165228.png" alt="image-20230906211326174"></p></li><li><p>方法：（二维坐标）将点(x, y)记为(x, y, 1), 将向量(x, y)记为(x, y, 0)</p></li><li><p>好处：</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165231.png" alt="image-20230906211516803"></p><p>  注：点 + 点 可得两点间中点</p><p>  即可将平移记为</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165234.png" alt="image-20230906211636249" style="zoom: 50%;"></li><li><p>注意：矩阵乘积顺序对结果有影响 齐次坐标前同一矩阵先运用线性变换在运用平移操作</p></li><li><p>思考：如何不绕原点旋转？</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165237.png" alt="image-20230906212021706"></p></li></ul><p>三维同理(x, y, z, 0), (x, y, z ,1)</p><hr><h3 id="观测变换（三维"><a href="#观测变换（三维" class="headerlink" title="观测变换（三维"></a>观测变换（三维</h3><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>绕谁谁不变</p><ul><li>循环对称性质</li></ul><p>$$<br>  绕x与z时，\vec{y}\times\vec{z} = \vec{x}，\vec{x}\times\vec{y} = \vec{z}，属于同一方向旋转（记为逆时针旋转<br>$$</p><p>$$<br>  而绕y旋转时，\overrightarrow{x}\times\overrightarrow{z} = -\overrightarrow{y}，故须旋转-\alpha<br>$$</p><p>* </p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165243.png" alt="image-20230907175453358" style="zoom:33%;"><ul><li>罗德里格斯旋转公式（复杂旋转转为xyz旋转<br>$$<br>绕旋转轴\overrightarrow{n}旋转\alpha度<br>$$<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165243.png" alt="image-20230907181022234" style="zoom: 33%;"></li></ul><h4 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h4><ul><li><p>三步变换（mvp变换</p><ol><li>模型变换：搭建场景</li><li>视图变换：找好相机角度</li><li>投影变换：将三维空间投影到二维平面</li></ol></li><li><p>相机</p><ul><li>放在哪（e）</li><li>往哪看（g）</li><li>向上方向（t）</li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165255.png" alt="image-20230907182706869" style="zoom: 33%;"><p>因为 相对移动</p><p>可假设相机一直在原点，朝向-z方向，y向上</p><p>//好处：扔掉z轴，呈现图像就是关于xy的平面图</p><ul><li><p>如何操作？</p><ol><li><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165259.png" alt="image-20230907183104377" style="zoom:33%;"></li><li><p>将<strong>g</strong>旋转到-<strong>z</strong>，<strong>t</strong>旋转到<strong>y</strong>，（<strong>g</strong> x <strong>t</strong>）旋转到<strong>x</strong> （难求）</p></li><li><p>故先将将-<strong>z</strong>旋转到<strong>g</strong>，<strong>y</strong>旋转到<strong>t</strong>，<strong>x</strong>旋转到（<strong>g</strong> x <strong>t</strong>），所需变换即该结果的逆</p></li><li><p>由于旋转矩阵为正交矩阵，矩阵的逆等于转置</p><p>故得<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165303.png" alt="image-20230907183902497" style="zoom:33%;"></p></li></ol></li></ul></li></ul><h4 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h4><ul><li><p>正交投影</p><ul><li><p>简单思路：将相机如上摆放后，使所有物体z=0，再将所有物体移到x、y均在-1到1的小方片上 即可将物体投影到xy平面，即正交投影的结果</p></li><li><p>正式做法：</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165308.png" alt="image-20230910194622039"></p><p>把任何形状变成标准立方体</p><ol><li>平移：把中心移到原点</li><li>缩放：把x、y、z宽度缩放为2（对应-1到1</li></ol><p>对应矩阵：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165312.png" alt="image-20230910195031304" style="zoom: 33%;"></li></ul></li><li><p>透视投影</p><ul><li><p>引子：齐次坐标性质</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165318.png" alt="image-20230911170159196"></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165353.png" alt="image-20230911170607698" style="zoom:33%;"></li><li><p>思路：</p><ol><li><p>将远平面挤到近平面相同大小</p><p>挤压过程中：</p><ul><li>近平面四个顶点不发生变化</li><li>原平面z轴不发生变化</li><li>远平面中心点不发生变化</li></ul></li><li><p>用正交投影方法将远平面投影到近平面上</p></li></ol><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420170144.png" alt="image-20230911171317815"></p><p>需要将矩阵化为</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165408.png" alt="image-20230911191530990" style="zoom:33%;"><p>即左乘矩阵<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165414.png" alt="image-20230911191827177" style="zoom:33%;"></p><ol><li><p>对于给定的深度n（在近平面上）：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165420.png" alt="image-20230911192059835" style="zoom:33%;"><p>故可得用待定系数法求第三行（与x、y无关，故前两项为0</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165427.png" alt="image-20230911192148729" style="zoom: 33%;"></li><li><p>对于远平面中心点：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165432.png" alt="image-20230911193102032" style="zoom:33%;"></li></ol><p>由1、2可得：<br>$$<br>\begin{cases}<br>\begin{aligned}<br>An + B = n^2\<br>Af +B=f^2<br>\end{aligned}<br>\end{cases}<br>\Rightarrow<br>\begin{cases}<br>\begin{aligned}<br>A=n+f\<br>B=-nf<br>\end{aligned}<br>\end{cases}<br>$$<br><strong>自此第一步把远平面挤压至近平面大小完成</strong></p><p>最终转化矩阵即此结果所求矩阵右乘正交转化矩阵</p></li><li><p>其他：经此变换后近平面、远平面的点z值不变，但中间的点z值并非不变(z变大，即变近)</p></li></ul></li></ul><hr><h3 id="光栅化成像"><a href="#光栅化成像" class="headerlink" title="光栅化成像"></a>光栅化成像</h3><h5 id="透视投影的视锥定义方式"><a href="#透视投影的视锥定义方式" class="headerlink" title="透视投影的视锥定义方式"></a>透视投影的视锥定义方式</h5><ol><li>视图宽高比</li><li>垂直可视角度（红线所成角度）（红线所连点为长宽中点）</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165437.png" alt="image-20230911204909056" style="zoom: 50%;"><p>光栅化：把东西画在屏幕上</p><p>即将[-1, 1]^2的方块映射到[0, width] * [0, height]的屏幕上</p><p>步骤：</p><ol><li><p>缩放：将[-1, 1]拉伸至需求大小</p></li><li><p>平移：由于坐标计算从左下角开始，需将中心平移至原点</p><p>合并1、2可得矩阵：<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165443.png" alt="image-20230911211622374" style="zoom:33%;"></p></li><li><p>光栅化：将图形打成像素</p></li></ol><p>三角形：最基础的多边形</p><h5 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h5><ul><li><p>概念：把函数离散化的过程</p></li><li><p>应用：设立函数，当中心在三角形内部时返回1，否则返回0</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165448.png" alt="image-20230912163111534" style="zoom:50%;"></li><li><p>具体实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> xmax<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> ymax<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>        image<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">inside</span><span class="token punctuation">(</span>tri<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>包围盒：找到顶点x、y的最小与最大值，形成包围盒 只用对其内的像素做光栅化处理</p></li></ul><h5 id="锯齿"><a href="#锯齿" class="headerlink" title="锯齿"></a>锯齿</h5><ul><li>原因：<ol><li>像素本身大小</li><li>采样率不够高</li></ol></li><li>抗锯齿/反走样</li></ul><h5 id="抗锯齿-反走样"><a href="#抗锯齿-反走样" class="headerlink" title="抗锯齿/反走样"></a>抗锯齿/反走样</h5><ul><li><p>现象（artifact）</p><ul><li>锯齿</li><li>摩尔纹</li><li>车轮效应（时间上的采样</li></ul></li><li><p>原因：信号速度太快 采样速度跟不上</p></li><li><p>反走样方法：在采样之前进行滤波/模糊</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165455.png" alt="image-20230912194812624" style="zoom:50%;"></li><li><p>why？</p></li></ul><p>$$<br>  定义\cos2\pi fx， f即频率<br>$$</p><ul><li><p>前言：<strong>傅里叶级数展开</strong></p><p>任何一个周期函数可以写成一系列正弦余弦的线性组合加常数的形式</p></li><li><p>引出：<strong>傅里叶变换</strong></p><ul><li><p>定义：给定任意一个函数可以经过一系列变换操作变为另一函数 通过逆变换可以变回原函数</p></li><li><p>作用：把一个函数从时域变到频域</p></li><li><p>例子：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165501.png" alt="image-20230912201416900" style="zoom:50%;"><p>右图为变换后图片 中间为低频 四周为高频 亮度表明图片信息主要集中于低频</p></li></ul></li><li><p>即 走样：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165507.png" alt="image-20230912200155332" style="zoom:50%;"></li></ul><h6 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h6><ul><li><p>意思：把某特定频段删去</p></li><li><p>例子（高通滤波）：用滤波将刚刚的图的低频信号滤去再逆变换为原图得到左图</p><p>可得高频主要为图像剧烈变换部分</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165516.png" alt="image-20230912201740247" style="zoom:50%;"></li><li><p>低通滤波：与上相反 边界模糊了</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165522.png" alt="image-20230912202128305" style="zoom:50%;"></li></ul><h6 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h6><ul><li><p>概念过程：下面三格窗口向右移动 与对应三数相乘后填回格子中</p><p>即对每三个各自做加权平均</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165530.png" alt="image-20230912202528804"></p></li><li><p>卷积定理：<strong>时域上的卷积等于频域上的乘积，频域上的卷积也等于时域上的乘积</strong>（卷积的对偶性）(互逆)</p><p>例：此例中任何一个像素等于周围像素平均 故得模糊图 频域上类似低通滤波</p><p>乘1/9使图像整体颜色(亮度)值经过卷积操作后不发生变化（求均值）</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165535.png" alt="image-20230912202928413"></p><p>卷积区域越大<code>(9*9 -&gt; 63*63)</code> 得到的图像越模糊 频域上白色越小、越接近中心</p></li></ul><h6 id="采样在频域上的意义"><a href="#采样在频域上的意义" class="headerlink" title="采样在频域上的意义"></a>采样在频域上的意义</h6><ul><li><p>冲激函数</p><p>只在特定位置上有值，其他位置上无值的函数（函数c）</p></li><li><p>采样即可表示为一个函数乘以一系列冲激函数后的结果</p><p>即 <code>a * c = e</code></p></li><li><p>对应的频域操作</p><p>即在频域上对对应的函数进行卷积操作 <code>b 卷积 d = f</code></p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165542.png" alt="image-20230918165042506" style="zoom:33%;"></li><li><p>即采样为<strong>频谱的重复</strong></p><p>得出产生走样现象的原因是采样频率不够快导致复制时采样的频谱出现了混叠</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165547.png" alt="image-20230918165449087" style="zoom:50%;"></li></ul><h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><ol><li><p>增加采样率</p><p>受制于物理限制</p></li><li><p>反走样</p><p><strong>先做模糊 再做采样</strong></p><p>即先进行低通滤波(去除高频) 再进行采样</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165552.png" alt="image-20230918170026947" style="zoom:50%;"><ul><li><p>例子</p><p>用大小为一个像素的低通滤波器对三角形进行卷积操作(取平均)</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165558.png" alt="image-20230918170720729" style="zoom:50%;"></li><li><p>怎么算？？(1)</p><p><strong>MSAA</strong>(对反走样的近似)</p><p>依靠<strong>模糊</strong>解决走样问题 <strong>并没有提高分辨率</strong></p><p>将一个像素拆分为几个较小像素(增加采样点) 取每个像素内采样点在三角形内的平均覆盖率 用此值乘以三角形原本颜色</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165603.png" alt="image-20230918171248715" style="zoom:25%;"><p>=&gt;</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165609.png" alt="image-20230918171309781" style="zoom:25%;"><p>由于采样频率为一个像素，此模糊操作结束后所得图形即反走样图形</p><p>代价：增大计算量</p></li><li><p>FXAA(Fast Approximate AA)</p><ol><li>得到一副有锯齿的图片</li><li>找到锯齿边界</li><li>替换为无锯齿边界</li></ol></li><li><p>TAA(Temporal AA)</p><p>复用上一帧的结果</p><p>相当于把MSAA对应的样本分布在时间上</p></li></ul></li></ol><h5 id="超分辨率"><a href="#超分辨率" class="headerlink" title="超分辨率"></a>超分辨率</h5><p>无锯齿放大图片分辨率</p><ul><li><p>DLSS(深度学习)</p><p>将细节猜出来</p></li></ul><p>与抗锯齿不同 但本质相同</p><h5 id="遮挡-深度"><a href="#遮挡-深度" class="headerlink" title="遮挡(深度)"></a>遮挡(深度)</h5><ul><li><p>画家算法<code>O(nlogn)</code></p><p>先画远的 再画近的</p><p>弊端：无法定义互相遮挡的深度关系</p></li><li><p>深度缓存 Z-Buffer<code>O(n)</code></p><p>生成结果图(frame buffer)的同时生成场景中任何一个像素的深度(depth(z) buffer)</p><p>注：始终假设相机看向-z 与这里的深度相反</p><p>一开始每个像素深度设为无限远 之后一步步记录到最小深度</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165614.png" alt="image-20230918195842260" style="zoom:50%;"><p>好处：结果与渲染顺序无关(由于浮点型判断相等十分困难 可假设没有两个图形位于同一深度的情况)</p></li></ul><hr><h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><ul><li>定义：对不同物体运用不同材质的过程</li><li>注：着色不包括阴影</li></ul><h4 id="基础着色模型-Blinn-Phong反射模型"><a href="#基础着色模型-Blinn-Phong反射模型" class="headerlink" title="基础着色模型(Blinn-Phong反射模型)"></a>基础着色模型(<code>Blinn-Phong反射模型</code>)</h4><p>物体表面颜色可分为</p><ol><li>物体高光</li><li>漫反射部分</li><li>间接光照</li></ol><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165627.png" alt="image-20230918202924853" style="zoom:50%;"><h5 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h5><p>假设物体一截取小段平面必为平面 定义 v为观测方向 l为光照方向 n为法线(<strong>均为单位向量</strong>) 及物体表面属性</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165634.png" alt="image-20230918203210649" style="zoom:50%;"><p>单位面积接收到的能量(光)与${\cos\theta = \vec l \cdot \vec n}$成正比</p><p>对于点光源的周围，假设光波传播过程中不消耗能量，则光传播越远光球壳表面积越大，单位面积能量就越小。设单位面积能量为<code>I</code>，则：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165643.png" alt="image-20230921002535608" style="zoom:50%;"><p>单位面积接收到的能量(光)与$r^2$成反比</p><p>即：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165650.png" alt="image-20230921003130086" style="zoom: 33%;"><p>注：$\vec n \cdot \vec l &lt; 0$时表示从面的一边射到面的另一边，在这里没有实际意义，故取0</p><p>系数<code>kd</code>为对漫反射颜色的吸收，可表示成[0, 1]的<code>rgb</code>的向量</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165657.png" alt="image-20230921004444372" style="zoom:33%;"><p>注2：漫反射能量与观测角度无关</p><h5 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h5><p>光滑的物体表面光的方向接近镜面反射，故只有观测角度与高光角度接近时才能看到高光</p><p>由于反射向量难以计算 可转化为法线向量与<code>半程向量</code>接近(点乘接近1)</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165702.png" alt="image-20230921005815645" style="zoom:50%;"><ol><li><p>高光一般为白色，故镜面反射系数<code>ks</code>一般为白色。</p></li><li><p>被吸收的能量(n 点乘 l)被简化</p></li><li><p>指数p可以提高容忍度(一般为100 到 200)</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165708.png" alt="image-20230921010427632" style="zoom:33%;"></li><li><p>例子：漫反射与高光结合后的图形</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165713.png" alt="image-20230921010522222" style="zoom:50%;"></li></ol><h5 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h5><p>由于环境光照过于复杂，假设任何一个点接触到的环境光照永远相同。实际为一个常数。</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165718.png" alt="image-20230921010833759" style="zoom:33%;"><p>对所有的点进行此着色模型可得：</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165722.png" alt="image-20230921011005078" style="zoom:50%;"><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165727.png" alt="image-20230921011048843" style="zoom:50%;"><h4 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h4><p>将着色运用在哪些点上</p><ul><li><p>Flat Shading<br>对三角形两边做叉积得到法线，并在每个三角形内部进行统一着色</p></li><li><p><code>Gouraud Shading</code><br>对平面的每个顶点周围三角形的法线求平均，进行着色，并在中间进行插值</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165732.png" alt="image-20230921012630037" style="zoom:25%;"></li><li><p><code>Phong Shading</code><br>求出顶点法线 在三角形内部对法线方向进行插值，得到任意一点的法线方向，对每个像素点进行着色</p></li></ul><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165737.png" alt="image-20230921012232928" style="zoom:50%;"><hr><h3 id="实时渲染管线"><a href="#实时渲染管线" class="headerlink" title="实时渲染管线"></a>实时渲染管线</h3><p>从三维场景到二维图的过程</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165742.png" alt="image-20230921183047880" style="zoom:50%;"><ol><li>输入顶点</li><li>生成三角形</li><li>光栅化</li><li>着色</li><li>纹理映射</li><li>输出</li></ol><p><code>Shader</code>即内置管线处理过程中可自定义修改部分。会自动应用在每个顶点或每个像素(片元)上</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165748.png" alt="image-20230921184458360" style="zoom:50%;"><p>其中用到简单的<code>Phong</code>模型光线计算</p><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>定义在着色过程中不同位置的不同物体属性(如漫反射系数)实现纹理</p><p>三维物体表面的纹理其实是二维的，物体表面上的点与二维图像上点的映射即纹理映射</p><h4 id="uv坐标"><a href="#uv坐标" class="headerlink" title="uv坐标"></a><code>uv坐标</code></h4><p>假设映射关系已知，设纹理图为在<code>uv坐标</code>上的一张图(u、v均在[0, 1])</p><p>tileable texture：将纹理复制连接在上下左右后依然连续</p><h4 id="重心坐标-插值"><a href="#重心坐标-插值" class="headerlink" title="重心坐标(插值)"></a>重心坐标(插值)</h4><ul><li>作用：做插值，在平面内进行平滑过渡</li><li>插值什么：颜色、法线…</li></ul><p>将三角形上任意一点表示为A B C坐标的线形组合，则重心为系数相加为1的点</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165753.png" alt="image-20230921194024695" style="zoom:50%;">即$\begin{cases} (x, y) = \alpha A+ \beta B + \gamma C\\alpha + \beta + \gamma = 1 \end{cases}$ , 可用$(\alpha, \beta, \gamma)$ 表示点(x, y)</p><p>仅当$\alpha、\beta、\gamma$均非负时，中心才在三角形内 如不满足$\alpha + \beta + \gamma = 1$则该点不在三角形的平面内</p><ol><li>由奔驰定理可求得每点的重心坐标 <img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165759.png" alt="image-20230921200550116" style="zoom:50%;"></li><li><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165804.png" alt="image-20230921200948917" style="zoom:50%;"></li></ol><p>而三角形重心的重心坐标即 $(\frac13, \frac13, \frac13)$</p><p>注：转换为投影坐标后<strong>不能</strong>保证重心坐标不变，故三维坐标下应<strong>先算出重心坐标</strong>，做完插值再进行投影操作</p><h4 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h4><h5 id="纹理太小"><a href="#纹理太小" class="headerlink" title="纹理太小"></a>纹理太小</h5><ul><li><p>简单方法：对每个像素点，计算出<code>uv</code>坐标，将对应的纹理设为该像素点的漫反射系数</p></li><li><p>问题：纹理太小无法完全覆盖所有像素点？（高分辨率下，<code>uv</code>坐标可能对应小数）</p></li><li><p>解决：坐标四舍五入，使多个像素点映射到同一个纹理点上，导致低分辨率</p></li><li><p>进一步解决：<strong>双线性插值</strong>（点查询）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165810.png" alt="image-20230926171320165" style="zoom:33%;"><p>取小数<code>uv</code>坐标周围四个点，进行水平方向和竖直方向上的插值，即可得到任意点的平滑过渡</p></li><li><p><strong>双三次插值</strong>/<strong>双立法插值</strong></p><p>取周围临近16个点做三次插值</p></li><li><p>结果对比</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165818.png" alt="image-20230926171836809" style="zoom:50%;"></li></ul><h5 id="纹理太大"><a href="#纹理太大" class="headerlink" title="纹理太大"></a>纹理太大</h5><ul><li><p>现象：严重的摩尔纹与锯齿（走样）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165824.png" alt="image-20230926180808796" style="zoom: 33%;"></li><li><p>原因：一个像素覆盖的纹理上的区域太大</p></li><li><p>解决方法：之前学过的<strong>超采样</strong> 可以解决，但消耗巨大</p></li></ul><h6 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h6><ul><li><p>方法2：不进行采样 即<strong>mipmap</strong>（图像金字塔）（范围查询）</p><p>快、近似、正方形</p><p>一共$\log_2n$层 存储量只多了$\frac13$</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165830.png" alt="image-20230927154435559" style="zoom:50%;"><p>近似方法：四周在<code>uv</code>坐标下距离差距的最大值L <code>L*L</code>即一个像素在<code>uv</code>坐标下的覆盖范围 这个正方形在Mipmap中第D层一定能取到<code>1*1</code>的大小</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165838.png" alt="image-20230927161329940" style="zoom:50%;"><p>结果：<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165843.png" alt="image-20230927162611719" style="zoom:50%;"></p><p>问题：会有分层不连续的结果</p><p>解决：<strong>三线性插值</strong>在上下两层分别进行双线性插值，再对两层的结果分别进行插值</p><p>结果:</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165849.png" alt="image-20230927163039095" style="zoom: 50%;"></li></ul><h6 id="各向异性过滤"><a href="#各向异性过滤" class="headerlink" title="各向异性过滤"></a>各向异性过滤</h6><ul><li><p>STILL问题：过分模糊<img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165857.png" alt="image-20230927163314457" style="zoom:50%;"></p></li><li><p>原因：1. 近似 2. 只能查询正方形，在计算长条形区域时加入了不必要的平均</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165902.png" alt="image-20230927163932352" style="zoom:50%;"></li><li><p>解决：各向异性过滤（<code>ripmap</code>）</p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420165908.png" alt="image-20230927163621568" style="zoom:33%;"><p>对于这张图，<code>mipmap</code>只实现对角线上图片，而这张图可以将查询范围从正方形扩大到矩形</p><p>内存变为原来的三倍</p><p>基本只影响显存开销，不增加计算量</p></li><li><p>still：对于斜向区域无法很好的近似</p></li><li><p><strong>EWA过滤</strong></p><p>基本思路：把一个不规则形状拆成很多圆形，多次查询覆盖原形状</p><p>问题：时耗大</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Graphics </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑器简单拓展</title>
      <link href="/posts/bian-ji-qi-jian-dan-tuo-zhan/"/>
      <url>/posts/bian-ji-qi-jian-dan-tuo-zhan/</url>
      
        <content type="html"><![CDATA[<h3 id="编辑器简单拓展"><a href="#编辑器简单拓展" class="headerlink" title="编辑器简单拓展"></a>编辑器简单拓展</h3><p>!!!<code>UnityEditor</code>不能被游戏内脚本引用 否则会导致打包失败</p><p><code>[HideInInspector]</code> 隐藏公共成员变量 防止inspector的值影响它</p><p><code>[SerializeField]</code> 使私有变量在检视面板可见[^1]</p><p><code>[Serializable]</code> 使<strong>对象</strong>可序列化</p><p><code>[Range(a, b)]</code> 使变量显示时显示a-b的滑动条范围</p><p><code>[Tooltip]</code> 在编辑器显示时的悬浮提示文字</p><p>*一个成员变量可添加多个特性</p><p><code>[Header("分类")]</code> 在上方显示小类名</p><p><code>[Space(50)]</code> 隔开50像素距离</p><p><code>[Multiline(5)]</code> 指定文字输入框为五行</p><p><code>[TextArea(5, 10)]</code> 使文本框在最小范围(5)到最大范围(10)之间自动变换 如多于最大行则以滚动条形式显示</p><p><code>[ContextMenu("函数作用")]</code> 使小齿轮处增加一个回调函数</p><p><code>[ContextMenuItem("悬浮显示提示", "回调函数名")]</code> 给成员变量添加右键菜单回调函数</p><p><code>[RequireComponent(typeof(组件名)]</code> 组件依赖 自动添加依赖的组件 且当改组件未被移除时依赖组件不允许删除</p><p><code>[ExecuteInEditMode]</code> 使生命周期函数在编辑器状态下可以执行(不影响游戏中正常使用) *Update在场景中对象发生变化或项目组织发生变化时会执行</p><p>[^1]: Unity会将对象进行序列化存储, 故私有变量标记为可序列化对象后可显示.公有变量默认可序列化.</p><hr><h3 id="编辑器深度拓展"><a href="#编辑器深度拓展" class="headerlink" title="编辑器深度拓展"></a>编辑器深度拓展</h3><p><code>[addComponentMenu("目录名/脚本名", 1)]</code> 将组建添加到<code>AddComponent</code>上, 目录名可省略 1为在列表中显示顺序 脚本名不用与类名相同</p><h4 id="检视器高级编程-外挂式编程"><a href="#检视器高级编程-外挂式编程" class="headerlink" title="检视器高级编程(外挂式编程)"></a>检视器高级编程(外挂式编程)</h4><p>在脚本外挂脚本从而修改脚本</p><ol><li>在项目中建立Editor目录</li><li>在目录中建立脚本控制脚本</li><li>将两个脚本关联<ol><li>引入<code>UnityEditor</code>命名空间</li><li>让Editor脚本继承Editor类</li><li><code>[CustomEditor(typeof("控制的类名"))]</code> 建立关联关系</li><li>创建成员变量 在<code>OnEnable()</code>函数中获得需要编辑显示组件</li></ol></li></ol><pre class="line-numbers language-c#"><code class="language-c#">private Player _Component;//当关联组件所在对象被选中或组件被添加时调用void OnEnable(){    _Component = target as Player;}//当关联组件所在对象被取消选中或组件被移除时调用void OnDisable(){    _Component = null;} //用于绘制检视面板的生命周期函数(每帧绘制编辑器时被调用)public override void OnInspectorGUI(){    //标题显示    EditorGUILayout.LabelField("标题名");    //赋值使在编辑器中对变量值的修改生效    _Component.ID = EditorGUILayout.IntField("显示名", _Component.ID);    //其他值类型同理 除布尔类型为EditorGUILayout.Toggle    //对象数据类型:显示名 值 类型 是否可以拖入赋值    _Component.Weapon = EditoeGUILayout.ObejectField("", _Component.Weapon, typeof("GameObject"), true) as GameObject;    //单选枚举    _Component.Pro = (枚举名)EditorGUILayout.EnumPopup("显示名", 值);    //多选枚举    _Component.Color = (枚举名)EditorGUILayout.EnumFlagsField("显示名", 值);    //终极数据类型绘制(支持任何数据类型)    //更新可序列化数据    serializedObject.Update();    //通过成员变量名找到组件上的成员变量    SerializedProperty sp = serializedObject.FindProperty("Items");    //可序列化数据绘制(取到的数据, 标题, 是否显示所有获得的序列化数据)    EditorGUILayout.PropertyField(sp, new GUIContent("道具信息"), true);    //将修改的数据写入可序列化的原始数据中    serializedObject.ApplyModifiedProperties();    //滑动条绘制(标题 值 最小值 最大值)    _Component.Atk = EditorGUILayout.Slider(new GUICoontent("玩家攻击力"), _Component.Atk, 0, 100);        if(_Component.Atk > 80){        //显示红消息框        EditorGUILayout.HelpBox("攻击力太高了", MessageType.Error);    }    if(_Component.Atk < 20){        //显示黄消息框        EditorGUILayout.HelpBox("攻击力太低了", MessageType.Warning);    }        //绘制按钮(默认纵向排列)    GUILayout.Button("按钮名");    //横向绘制    EditorGUILayout.BeginHorizontal();    if(GUILayout.Button("检查")){        Debug.Log("检查");    }    if(GUILayout.Button("排查")){        Debug.Log("排查");    }    EditorGUILayout.EndHorizontal();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h4><pre class="line-numbers language-c#"><code class="language-c#">using UnityEditor;public class PopWindow : EditorWindow{    //使顶部菜单出现方法    [MenuItem("工具/创建窗口")]    static void OpenWindow(){        //泛型内类型表示用哪个脚本创建窗口(是否为工具窗口 标题 是否打开立刻获得焦点)        GetWindow<PopWindow>(false, "弹窗标题", true);        window.minSize = new Vector(400, 300);        window.maxSize = new Vector(800, 600);    }    //打开窗口时调用    private void OnEnable(){            }    //关闭窗口时调用    private void OnDisable(){            }    //窗口处于开启状态时调用    private void Update(){            }    private void OnGUI(){        //在此可用上面OnInspectorGUI中函数绘制界面       }    //当场景发生变化时执行    private void OnHierarchyChange(){            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Study </tag>
            
            <tag> Unity Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恋上算法与数据结构笔记</title>
      <link href="/posts/lian-shang-suan-fa-yu-shu-ju-jie-gou-bi-ji/"/>
      <url>/posts/lian-shang-suan-fa-yu-shu-ju-jie-gou-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        value <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>思路:链表只能获取每个节点的值和它的下一个节点 删除节点(对外)只需要删除这个数据</p><ol><li><p>将要删除的节点的下一个节点的数据覆盖到该节点</p></li><li><p>让该节点指向下一个节点的下一个节点</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token punctuation">.</span>value <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ol><li><p>每次用<code>reverseList(head.next)</code>获取从下一个节点开始反转之后的链表</p></li><li><p>让head的下一个节点指向head</p></li><li><p>让head指向空</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//空链表或只有一个节点</span>        ListNode newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从head.next开始反转，得到的newHead相当于图片中红框部分。</span>    head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//head.next为4，将4的next指向5</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使5的next指向null</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><ol><li>创建一个新空链表<code>newHead</code></li><li>让head节点指向<code>newHead</code></li><li>让<code>newHead</code>指向head节点</li><li>让head指向下一个节点</li><li>循环直到head指向空</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseList2</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode newHead <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode temp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>        newHead <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="环形链表-快慢指针"><a href="#环形链表-快慢指针" class="headerlink" title="环形链表-快慢指针"></a>环形链表-快慢指针</h3><ol><li>定义两个指针 一个跑得快 一个跑得慢</li><li>如果有环形链表 快指针和慢指针一定会有时刻重合(快的一定会追上慢的)</li><li>如果不是环形链表 快的一定会先指向null</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>元素必大于左子树上的任何元素, 小于右子树上的任何元素</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>    E element<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//父节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> left<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//右子节点</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><ol><li>找到父节点</li><li>创建新节点</li><li>将节点插入空位</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E element<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//添加的节点为根节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//添加的节点不是根节点</span>    <span class="token comment" spellcheck="true">//找到父节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> parent <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存最后一个找到的节点</span>    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存最后一次比较的结果</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        cmp <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> node<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>                parent <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//相等</span>            <span class="token comment" spellcheck="true">//不允许相等：两种方法 1.忽略(chosen) 2.覆盖</span>            <span class="token comment" spellcheck="true">//允许相等：合并入上面的一种情况</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入方向</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h4><ol><li>删除节点为叶子节点：直接删除</li><li>度为1的节点：用子节点替代原节点位置</li><li>度为2的节点：用此节点的前驱节点或后继节点代替此节点</li></ol><p>注：如果一个节点的度为2，那么它的前驱、后继节点的度只可能是0或1</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//度为2</span>        <span class="token comment" spellcheck="true">//找到前驱节点</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> p <span class="token operator">=</span> <span class="token function">preccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//用前驱节点的值覆盖度为2的节点的值</span>        node<span class="token punctuation">.</span>element <span class="token operator">=</span> p<span class="token punctuation">.</span>element<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//删除前驱节点</span>        node <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//删除node</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> replacement <span class="token operator">=</span> node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">?</span> node<span class="token punctuation">.</span>left <span class="token operator">:</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>replacement <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//node是度为1的节点</span>        <span class="token comment" spellcheck="true">//更改parent</span>        replacement<span class="token punctuation">.</span>parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//更改parent的left\right指向</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            root <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> replacement<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//node是叶子节点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            root <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="前序遍历-Preorder-Traversal"><a href="#前序遍历-Preorder-Traversal" class="headerlink" title="前序遍历(Preorder Traversal)"></a>前序遍历(<code>Preorder Traversal</code>)</h4><p>访问顺序: 根节点, 前序遍历左子树, 前序遍历右子树(类似<code>dfs</code>)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//访问操作</span>    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历-Inorder-Traversal"><a href="#中序遍历-Inorder-Traversal" class="headerlink" title="中序遍历(Inorder Traversal)"></a>中序遍历(<code>Inorder Traversal</code>)</h4><p>访问顺序: 中序遍历左子树, 根节点, 中序遍历右子树(或左右互换)</p><p>特性: 访问后数据为升序(如先访问右子树则为降序)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//访问操作</span>    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序遍历-Postorder-Traversal"><a href="#后序遍历-Postorder-Traversal" class="headerlink" title="后序遍历(Postorder Traversal)"></a>后序遍历(<code>Postorder Traversal</code>)</h4><p>访问顺序: 后序遍历左子树, 后序遍历右子树, 根节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//访问操作</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="层序遍历-Lever-Order-Traversal"><a href="#层序遍历-Lever-Order-Traversal" class="headerlink" title="层序遍历(Lever Order Traversal)"></a>层序遍历(Lever Order Traversal)</h4><p>访问顺序: 从上到下 从左到右访问(类似于<code>bfs</code>)</p><p>思路: 队列</p><ol><li>将根节点入队</li><li>循环执行:<ol><li>将队头节点a出队并访问</li><li>将a的左子节点入队</li><li>将a的右子节点入队</li></ol></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelOrderTraversal</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//访问node</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//递归</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">height</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//迭代(层序遍历)</span><span class="token comment" spellcheck="true">//思路: 每层最后一个访问完后队列中元素数量即下一层元素数量</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rowSize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        Queue<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rowSize <span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rowSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            rowSize <span class="token operator">=</span> queue<span class="token punctuation">.</span>size<span class="token punctuation">;</span>            height <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断完全二叉树-利用层序遍历"><a href="#判断完全二叉树-利用层序遍历" class="headerlink" title="判断完全二叉树(利用层序遍历)"></a>判断完全二叉树(利用层序遍历)</h3><ol><li>树为空 否</li><li>左右都非空 将子节点入队</li><li>左空右非空 否</li><li>左非空右空 或 左右都空 之后节点应均为叶子节点 否则为否</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> leaf<span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>leaf <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token punctuation">.</span>isLeaf<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><p>只要保证遍历到每个节点并交换均可</p><p><em>中序遍历需注意遍历完左子树交换后传入另一子树（仍为左子树）</em></p><p>eg.层序遍历（迭代）：</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    TreeNode* invertTree(TreeNode* root) {        queue<TreeNode *> nodes;        nodes.push(root);        while (!nodes.empty())        {            TreeNode * node = nodes.front();            if(node != NULL){                TreeNode * temp = node->left;                node->left = node->right;                node->right = temp;                nodes.push(node->left);                nodes.push(node->right);            }            nodes.pop();        }                return root;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>eg.前序遍历（递归）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        TreeNode tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重构二叉树"><a href="#重构二叉树" class="headerlink" title="重构二叉树"></a>重构二叉树</h3><ul><li><p>前序遍历 + 中序遍历</p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {        if(preorder.size() == 0 || inorder.size() == 0) return NULL;        TreeNode * root = new TreeNode(preorder[0]);                int i;        for (i = 0; i < inorder.size(); i++)        {            if(inorder[i] == preorder[0]) break;        }                vector<int> leftpreorder((preorder.begin() + 1), (preorder.begin() + i + 1));        vector<int> rightpreorder((preorder.begin() + 1 + i), (preorder.end()));        vector<int> leftinorder((inorder.begin()), (inorder.begin() + i));        vector<int> rightinorder((inorder.begin() + 1 + i), (inorder.end()));        root->left = buildTree(leftpreorder, leftinorder);        root->right = buildTree(rightpreorder, rightinorder);        return root;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>后序遍历 + 中序遍历</p></li><li><p>前序遍历 + 后序遍历 + 真二叉树（节点的子节点数为0或2）</p><p><img src="https://raw.gitmirror.com/mashimarokumo/blogResources/master/res/20240420172637.png" alt="image-20230906195154383"></p></li></ul><h3 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h3><ul><li><p>概念：中序遍历时的前一个节点</p></li><li><p>思路：在二叉搜索树中即为前一个比它小的节点</p><p>​左子树非空时 为左子树中最大节点</p><p>​左子树空父节点非空时 向上找父节点直到node在parent右子树中</p><p>​否则 无前驱节点</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">predecessor</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//前驱节点在左子树当中(left.right.right.right...)</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> p <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//从父结点、祖父节点中寻找前驱节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//node.parent == null(没有前驱节点)</span>    <span class="token comment" spellcheck="true">//node == node.parent.right(前驱节点即父节点)</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h3><p>与前驱节点相反</p><ul><li><p>右子树非空时 为右子树中最小节点</p><p>右子树空父节点非空时 向上找父节点直到node在parent左子树中</p><p>否则无后继节点</p></li></ul><p>将上述代码中left改成right，right改成left即可</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li><p>原因：分析 二叉搜索树增 删 查复杂度均与由树高决定</p><p>如从小到大添加节点会退化成链表</p></li><li><p>平衡：节点数相同时，左右子树高度越接近树就越平衡</p></li><li><p>平衡因子：某节点左右子树高度差</p></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>每个节点的平衡因子只可能是1， 0， -1 否则为失衡</li><li>每个节点的左右子树高度差不超过1</li><li>增删改的时间复杂度为O(logn)</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>添加元素时 父节点不可能失衡 其他所有祖先节点都可能失衡</li></ul><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>原地建堆</p><p>重复执行以下步骤直到堆中元素为1</p><ol><li><p>将堆顶元素与堆底元素交换</p></li><li><p>将堆大小-1</p></li><li><p>将堆顶元素下滤</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>heapSize <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h3><p>find O(1) 找到节点父节点</p><p>union O(n) 让左边与集合内所有元素指向节点指向右边父节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> parents<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    parents<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//父节点就是根节点</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//将v1的所有元素嫁接到v2的父节点上</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> parents<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parents<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p1<span class="token punctuation">)</span><span class="token punctuation">{</span>            parents<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSame</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    retrun <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h3><p>find <code>O(logn)</code> 找到节点根节点</p><p>union <code>O(logn)</code> 让左边根节点指向右边根节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//不断向上,直到找到根节点</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        v <span class="token operator">=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//将v1的根节点嫁接到v2的根节点上</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="基于Quick-Union优化"><a href="#基于Quick-Union优化" class="headerlink" title="基于Quick Union优化"></a>基于Quick Union优化</h4><p>可能出现树不平衡,退化至链表,使find=O(n)</p><h5 id="基于size的优化"><a href="#基于size的优化" class="headerlink" title="基于size的优化"></a>基于size的优化</h5><p> 元素少的嫁接到元素多的</p><pre class="line-numbers language-java"><code class="language-java">sizes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sizes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sizes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sizes<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sizes<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>        sizes<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">+=</span> sizes<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> p1<span class="token punctuation">;</span>        sizes<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">+=</span> sizes<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a>基于rank的优化</h5><p>矮的树嫁接到高的树</p><pre class="line-numbers language-java"><code class="language-java">ranks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sizes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ranks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ranks<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ranks<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ranks<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">></span> ranks<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">=</span> p1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">;</span>        ranks<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="路径压缩-基于Quick-Union-rank优化"><a href="#路径压缩-基于Quick-Union-rank优化" class="headerlink" title="路径压缩(基于Quick Union-rank优化)"></a>路径压缩(基于Quick Union-rank优化)</h5><p>在find时使路径上所有节点指向根节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="路径分裂"><a href="#路径分裂" class="headerlink" title="路径分裂"></a>路径分裂</h5><p>使路径上的每个节点指向它的祖父节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>        parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> parents<span class="token punctuation">[</span>parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="路径减半"><a href="#路径减半" class="headerlink" title="路径减半"></a>路径减半</h5><p>是路径上每隔一个节点就指向其祖父节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>v <span class="token operator">!=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> parents<span class="token punctuation">[</span>parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> parents<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericUnionFind</span><span class="token operator">&lt;</span>V<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Mao<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>V<span class="token operator">>></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSet</span><span class="token punctuation">(</span>V v<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nodes<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> rerurn<span class="token punctuation">;</span>            nodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">findNode</span><span class="token punctuation">(</span>V v<span class="token punctuation">)</span><span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>V<span class="token operator">></span> node <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索 (Breadth First Search)"></a>广度优先搜索 (Breadth First Search)</h4><p>以与初始节点的距离大小为顺序遍历</p><p>思路：用队列 将初始节点加入队列 之后每取出一个节点就将此节点的子节点放入队列 已加入过的节点忽略</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> beginVertex<span class="token punctuation">)</span><span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> visitedVertices <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Queue<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>visitedVertices<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索 (Depth First Search)"></a>深度优先搜索 (Depth First Search)</h4><p>每次走到最大距离 然后往回退走下一条路的最大距离</p><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><p>思路：递归，每次遍历该节点的子节点（子节点又会遍历自己的子节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> visitedVertices<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历</span>    visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>vertex<span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>visitedVertices<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">,</span> visitedVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h5><p>思路: 利用栈 先将第一个节点加入栈中</p><ol><li>弹出顶上的节点,打印节点</li><li>选择此节点的一条边的to节点(未被加入过的)</li><li>将此节点和to节点加入栈中</li><li>重复上述操作 直到栈为空</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>V begin<span class="token punctuation">)</span><span class="token punctuation">{</span>    Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> beginVertex <span class="token operator">=</span> vertices<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>beginVertex <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> visitedVertices <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> stack <span class="token operator">-</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>beginVertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>visitedVertices<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            visitedVertices<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//拿到一条边后就结束循环</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="AOV网-拓扑排序-topologicalSort"><a href="#AOV网-拓扑排序-topologicalSort" class="headerlink" title="AOV网-拓扑排序 (topologicalSort)"></a>AOV网-拓扑排序 (<code>topologicalSort</code>)</h3><p>作用: 使AOV网中每个活动的前去活动都排在该活动的前面</p><p>条件: 有向无环图</p><h4 id="卡恩算法"><a href="#卡恩算法" class="headerlink" title="卡恩算法"></a>卡恩算法</h4><p>思路: </p><ol><li>将所有入度为零的节点值放入结果列表</li><li>将此节点从图中去除</li><li>重复操作,直到没有入度为零的节点</li></ol><p>结果:</p><ol><li>如果结束后列表中元素与定点总数相同,说明拓扑排序完成</li><li>如果结束后列表中元素个数小于定点总数,说明存在环,无法完成拓扑排序</li></ol><p>缺点: 需将顶点从图中删除 不符合设计原则</p><p>优化: 创建入度表,每次将节点值放入结果列表时将其所有<code>outEdges</code>对应to节点的入度减一,达成删除节点同效果.</p><p>​细节优化:一开始入度就为零的节点不涉及入度修改,不用放入入度表</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>V<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArryList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果列表</span>    Queue<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">>></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//入度为零的节点</span>    Map<span class="token operator">&lt;</span>Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span><span class="token punctuation">,</span> Integer<span class="token operator">></span> ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//入度表</span>    <span class="token comment" spellcheck="true">//初始化 将初始入度为零的放入队列</span>    vertices<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>V v<span class="token punctuation">,</span> Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">int</span> in <span class="token operator">=</span> vertex<span class="token punctuation">.</span>inEdges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            ins<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>vertex<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Vertex<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> vertex <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 放入返回结果</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>Edge<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> E<span class="token operator">></span> edge <span class="token operator">:</span> vertex<span class="token punctuation">.</span>outEdges<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> toIn <span class="token operator">=</span> ins<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>toIn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>to<span class="token punctuation">,</span> toIn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my fist blog!!!!!!</title>
      <link href="/posts/my-first-blog/"/>
      <url>/posts/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>The first time for me to create a blog desu!!!!!!!!!!!!!!!!!!!!!!!!!!!!!w</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
